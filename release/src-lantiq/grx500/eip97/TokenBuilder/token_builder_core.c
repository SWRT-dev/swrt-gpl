/* File token_builder_core.c
   code generated by tbgen.py */

/*****************************************************************************
* Copyright (c) 2011-2013 INSIDE Secure B.V. All Rights Reserved.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 2 of the License, or
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
****************************************************************************/


/*----------------------------------------------------------------------------
 * This module implements (provides) the following interface(s):
 */

#include "token_builder.h"

/*----------------------------------------------------------------------------
 * This module uses (requires) the following interface(s):
 */

#include "c_token_builder.h"
#include "basic_defs.h"
#include "token_builder_internal.h"
#include "token_builder_macros.h"

#include "log.h"

TokenBuilder_Status_t
TokenBuilder_GetSize(
    const void * const TokenContext_p,
    unsigned int * const TokenWord32Count_p
    )
{
    const TokenBuilder_Context_t *TokenContext_Internal_p =
        (const TokenBuilder_Context_t*)TokenContext_p;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u || 1
    uint32_t proto;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || (TKB_HAVE_PROTO_SSLTLS == 1u && !TKB_SINGLE_PASS_SSLTLS == 1u)
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u)
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif

#ifdef TKB_STRICT_ARGS_CHECK
    if (TokenWord32Count_p == NULL || TokenContext_p == NULL)
    {
        LOG_CRIT("TokenBuilder_GetSize: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif

    *TokenWord32Count_p = TKB_TOKEN_HEADER_WORD_COUNT;

    *TokenWord32Count_p += 2u;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
    proto = EVAL_proto();
    if (proto >= 25u)
    {
        *TokenWord32Count_p += 1u;
    }
#endif
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (ivhandling > 13u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 10u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 11u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
    }
    *TokenWord32Count_p += 1u;
    proto = EVAL_proto();
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (ivhandling == 2u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
                if (extseq > 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 9u;
#else
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 6u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 3u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 6u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            *TokenWord32Count_p += 3u;
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 4u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 4: /* upd_blk */
            *TokenWord32Count_p += 4u;
            break;
        }
#else
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
#if TKB_SINGLE_PASS_SSLTLS == 1u
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 4u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
            }
            *TokenWord32Count_p += 5u;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                *TokenWord32Count_p += 1u;
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            case 1: /* upd_arc4 */
                *TokenWord32Count_p += 5u;
                break;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                *TokenWord32Count_p += 6u;
            }
            else
            {
                *TokenWord32Count_p += 10u;
            }
            *TokenWord32Count_p += 2u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 4u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            *TokenWord32Count_p += 2u;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 3u;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            }
        }
#else
        *TokenWord32Count_p += 1u;
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 4u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
        }
        *TokenWord32Count_p += 3u;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            *TokenWord32Count_p += 1u;
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else if (extseq == 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 5u;
            break;
        case 2: /* upd_iv2 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 3: /* upd_iv4 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 4: /* upd_blk */
            *TokenWord32Count_p += 1u;
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else if (extseq == 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            break;
        }
#endif
#else
#endif
        break;
    case 21: /* ssltls_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 4u;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 5u;
        if (extseq != 0u)
        {
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 5u;
#else
#endif
        break;
    case 22: /* ssltls_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 4u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (extseq == 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 4u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 5u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 3u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 3u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        if (ivhandling == 5u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 3u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 3u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        *TokenWord32Count_p += 5u;
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 3u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
#else
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    default:
        ;
    }


   return TKB_STATUS_OK;
}


TokenBuilder_Status_t
TokenBuilder_BuildToken(
    const void * const TokenContext_p,
    const uint8_t *const Packet_p,
    const uint32_t PacketByteCount,
    const TokenBuilder_Params_t * const TKBParams_p,
    void * const Token_p,
    uint32_t * const TokenWord32Count_p,
    uint32_t * const TokenHeaderWord_p)
{
    uint32_t *tp = (uint32_t*)Token_p;
    const TokenBuilder_Context_t *TokenContext_Internal_p =
        (const TokenBuilder_Context_t*)TokenContext_p;
    uint32_t proto;
    uint32_t packetsize;
    uint32_t bypass;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t nextheader;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_remainder;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_blocksize;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t pad_bytes;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && !TKB_SINGLE_PASS_SSLTLS == 1u)
    uint32_t pad_bytes_in;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t iv_offset;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t salt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_salt;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t paylen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swap_fraglen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t hashpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_pkt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_tkn;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_out;
#endif
#if TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t swap_j;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_swaplen;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_swap;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_hashpad;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u)
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u
    uint32_t appendhash;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t pad_bytes_basic;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_offset;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_swaproc;
#endif
    uint32_t srtp_iv0;
    uint32_t srtp_iv1;
    uint32_t srtp_iv2;
    uint32_t srtp_iv3;
    uint32_t count;
    uint32_t bearer_dir_fresh;
    uint32_t per_packet_options;
    uint32_t cw0;
    uint32_t cw1;
    const uint8_t *iv;
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u)
    const uint8_t *ssltls_lastblock;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u)
    const uint8_t *ssltls_lastword;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *aad;
#endif

    IDENTIFIER_NOT_USED(Packet_p);
#ifdef TKB_STRICT_ARGS_CHECK
    if (TokenContext_p == NULL || Token_p == NULL ||
        TokenWord32Count_p == NULL ||
        (TokenHeaderWord_p == NULL && TKB_TOKEN_HEADER_WORD_COUNT == 0))
    {
        LOG_CRIT("TokenBuilder: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif

    if (TokenHeaderWord_p != NULL)
        *TokenHeaderWord_p = EVAL_TokenHeaderWord();
#if TKB_TOKEN_HEADER_WORD_COUNT > 0
    {
        unsigned int i;
        *tp++ = EVAL_TokenHeaderWord();
        for (i = 0; i < TKB_TOKEN_HEADER_WORD_COUNT - 1; i++)
        {
            *tp++ = 0;
        }
    }
#endif

    per_packet_options = EVAL_per_packet_options();
    if (per_packet_options != 0u)
    {
        /* DATA32 cw0 + per_packet_options */
        cw0 = EVAL_cw0();
        *tp++=0x00000000 | ((cw0+per_packet_options)&0xffffffffu)<<0;
        /* DATA32 cw1 */
        cw1 = EVAL_cw1();
        *tp++=0x00000000 | ((cw1)&0xffffffffu)<<0;
    }
    proto = EVAL_proto();
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
    if (proto >= 25u)
    {
        /* DATA32 nextheader   ; Specify number of valid bits in last byte for */
        nextheader = EVAL_nextheader();
        *tp++=0x00000000 | ((nextheader)&0xffffffffu)<<0;
    }
#endif
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 8);
            tp += 2;
        }
        else if (ivhandling > 13u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 16);
            tp += 4;
        }
        else if (ivhandling == 10u)
        {
            /* DATA32 srtp_iv0 */
            srtp_iv0 = EVAL_srtp_iv0();
            *tp++=0x00000000 | ((srtp_iv0)&0xffffffffu)<<0;
            /* DATA32 srtp_iv1 */
            srtp_iv1 = EVAL_srtp_iv1();
            *tp++=0x00000000 | ((srtp_iv1)&0xffffffffu)<<0;
            /* DATA32 srtp_iv2 */
            srtp_iv2 = EVAL_srtp_iv2();
            *tp++=0x00000000 | ((srtp_iv2)&0xffffffffu)<<0;
            /* DATA32 srtp_iv3 */
            srtp_iv3 = EVAL_srtp_iv3();
            *tp++=0x00000000 | ((srtp_iv3)&0xffffffffu)<<0;
        }
        else if (ivhandling == 11u)
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
        else
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
            /* DATA32 count */
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
    }
    bypass = EVAL_bypass();
    if (bypass > 0u)
    {
        if (proto != 9u)
        {
            /* DIR OUT,bypass */
            *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
        }
    }
    packetsize = EVAL_packetsize();
    if (packetsize > 131071u)
    {
        LOG_WARN("TokenBuilder: bad packet, too long\n");
        return TKB_BAD_PACKET;
    }
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound\n");
            return TKB_BAD_PACKET;
        }
        if (ivhandling == 2u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,8+ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        /* DIR      CRYPTHASH,packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
                /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      CRYPT,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASHPKT */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d260000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        extseq = EVAL_extseq();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound\n");
            return TKB_BAD_PACKET;
        }
        if (ivhandling == 0u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
            /* RETR     HASHONLY,ORIG_IV1,ivlen */
            *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,8+ivlen */
            *tp++=0x42900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
                *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST */
                *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
                /* INS   HASHONLY, ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* RETR  NONE,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* VERIFY   icvlen,S,SP,P,H */
                *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
                if (extseq > 0u)
                {
                    /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
                }
                else
                {
                    /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
                }
            }
            else
            {
                /* VERIFY   icvlen,SP,P,H */
                *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* DIR CRYPT,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            /* VERIFY   0,SP,P */
            *tp++=0xd5060000 | ((0u)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound CCM\n");
            return TKB_BAD_PACKET;
        }
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* INS      HASHONLY,ORIG_IV1,8 */
        *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6     ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                     ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* DATA32   0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((6u)&0x1ffu)<<0;
        }
        else
        {
            /* DATA32   0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((2u)&0x1ffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        else
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((hashpad)&0x1ffu)<<0;
        }
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound CCM\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound CCM\n");
            return TKB_BAD_PACKET;
        }
        /* RETR     NONE,ORIG_SPI,8 */
        *tp++=0x40900000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* RETR     HASHONLY,ORIG_IV1,8 */
        *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6    ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                    ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* DATA32 0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,8 */
            *tp++=0x22900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((6u)&0x1ffu)<<0;
        }
        else
        {
            /* DATA32 0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,4 */
            *tp++=0x22900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES, 4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((2u)&0x1ffu)<<0;
        }
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST */
            *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((hashpad)&0x1ffu)<<0;
        }
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen,SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GCM\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8,LAST */
            *tp++=0x2b900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4, LAST */
            *tp++=0x2b980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8,LAST */
            *tp++=0x4a900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4,LAST */
            *tp++=0x2a980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     NONE,ORIG_IV1,ivlen */
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen,SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      HASH,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      HASH, packetsize-bypass */
        *tp++=0x03000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS      HASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2b220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     HASHONLY,ORIG_IV1,ivlen */
        *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      HASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
        *tp++=0x0b020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen, SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
            *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,ORIG_SPI,2           ; For SSL, do not hash version field. */
            *tp++=0x21900000 | ((2u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV0,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a00000 | ((ivlen)&0x1ffffu)<<0;
        if (packetsize != bypass)
        {
            /* DIR CRYPTHASH, packetsize-bypass,LASTHASH */
            *tp++=0x07020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LASTHASH */
            *tp++=0x27020000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 1: /* upd_arc4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
            *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,2,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,4,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        case 4: /* upd_blk */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, payload size for SSLTLS inbound\n");
            return TKB_BAD_PACKET;
        }
#if TKB_SINGLE_PASS_SSLTLS == 1u
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            if (bypass > 0u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* DIR HASHONLY,3       ; Hash type and version number */
                    *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,1       ; Hash type only for SSL */
                    *tp++=0x02000000 | ((1u)&0x1ffffu)<<0;
                    /* REM 2 */
                    *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,ORIG_TOKEN,2 */
            *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* REMRES bypass+paylen,icvlen          ; Cause the MAC to be removed */
            icvlen = EVAL_icvlen();
            *tp++=0xa0000000 | ((bypass+paylen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIR CRYPTHASH,paylen,LASTHASH */
            *tp++=0x07020000 | ((paylen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,S,H */
                    *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            case 1: /* upd_arc4 */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
                *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
                break;
            }
        }
        else
        {
            /* REMRES 0,4,LASTINS */
            *tp++=0xa0020000 | ((0u)&0xffffu)<<0 | ((4u)&0x3fu)<<19;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                /* INS CRYPTONLY,ORIG_TOKEN,12 */
                *tp++=0x24d80000 | ((12u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 12);
                tp += 3;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            else
            {
                /* INS CRYPTONLY,ORIG_TOKEN,28 */
                *tp++=0x24d80000 | ((28u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 28);
                tp += 7;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            /* DIR NONE,0,LAST */
            *tp++=0x08000000 | ((0u)&0x1ffffu)<<0;
            if (bypass > 0u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* INS HASHONLY,ORIG_SPI_RES,3       ; Hash type and version number */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_SPI_RES,1       ; Hash type only. */
                    *tp++=0x22c00000 | ((1u)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,ORIG_LENCOR,paylen-1 */
            *tp++=0x22780000 | ((-1u+paylen)&0x1ffffu)<<0;
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                /* RETR NONE,ORIG_IV0,ivlen */
                *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            }
            /* REMRES bypass,icvlen,LASTINS          ; Cause the MAC to be removed */
            icvlen = EVAL_icvlen();
            *tp++=0xa0020000 | ((bypass)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIRX CRYPTHASH,ORIG_LENCOR,0,LASTHASH */
            *tp++=0x077a0000 | ((0u)&0x1ffffu)<<0;
            /* DIRX CRYPT,ORIG_LENCOR,icvlen+1,LAST,LASTHASHPKT */
            *tp++=0x0d7e0000 | ((1u+icvlen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,2,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,4,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,P,S,H */
                    *tp++=0xd9070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            }
        }
#else
        if (bypass > 0u)
        {
            /* DIR OUT,bypass */
            *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
            *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
            *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SEQNUM,4 */
            *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR HASHONLY,3       ; Hash type and version number */
                *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,1       ; Hash type only for SSL */
                *tp++=0x02000000 | ((1u)&0x1ffffu)<<0;
                /* REM 2 */
                *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            }
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* REM 2                              ; Remove fragment length. */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            /* RETR NONE,ORIG_IV0,ivlen */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
        }
        /* REMRES bypass+paylen,icvlen          ; Cause the MAC to be removed */
        icvlen = EVAL_icvlen();
        *tp++=0xa0000000 | ((bypass+paylen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
        /* DIR CRYPTHASH,paylen,LASTHASH */
        *tp++=0x07020000 | ((paylen)&0x1ffffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
            if (extseq == 0u)
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            }
            else if (extseq == 1u)
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,S,H */
                *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
            }
            break;
        case 1: /* upd_arc4 */
            /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
            *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* DIR CRYPT,icvlen,LASTHASH */
                *tp++=0x05020000 | ((icvlen)&0x1ffffu)<<0;
                /* DIR CRYPTONLY,pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0c060000 | ((pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,2,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* DIR CRYPT,icvlen,LASTHASH */
                *tp++=0x05020000 | ((icvlen)&0x1ffffu)<<0;
                /* DIR CRYPTONLY,pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0c060000 | ((pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,4,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        case 4: /* upd_blk */
            /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
            pad_bytes_in = EVAL_pad_bytes_in();
            *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
            if (extseq == 0u)
            {
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            }
            else if (extseq == 1u)
            {
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,P,S,H */
                *tp++=0xd9070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
            }
            break;
        }
#endif
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 21: /* ssltls_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound GCM\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 ; Output sequence number for DTLS */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2,LAST */
        *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        if (extseq != 0u)
        {
            if (hstatelen != 0u)
            {
                /* REMRES bypass + 4 + 5 + 8 + 8, 16 */
                *tp++=0xa0000000 | ((25u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
            else
            {
                /* REMRES bypass + 5 + 8 + 8, 16 */
                *tp++=0xa0000000 | ((21u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
        }
        else
        {
            /* REMRES bypass + 5 + 8, 16 */
            *tp++=0xa0000000 | ((13u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        if (packetsize != bypass)
        {
            /* DIR CRYPTHASH, packetsize-bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LAST, LASTHASH */
            *tp++=0x2f020000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 22: /* ssltls_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
            *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
            *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SEQNUM,4 */
            *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            /* DIR HASHONLY,3       ; Hash type and version number */
            *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2,LAST */
        *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* REM 2                              ; Remove fragment length. */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR CRYPTHASH, paylen,LAST,LASTHASH */
        *tp++=0x0f020000 | ((paylen)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        if (extseq == 0u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
        }
        else if (extseq == 1u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        }
        else
        {
            /* VERIFY icvlen,S,H */
            *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            printk("TokenBuilder: bad packet, too short for basic crypto\n");
            return TKB_BAD_PACKET;
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  OUT,ORIG_IV1,8 */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  OUT,ORIG_IV0,8 */
            *tp++=0x21a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            printk("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            printk("TokenBuilder: bad packet, too short for basic crypthash\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR HASHONLY,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x42a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  HASH,ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR HASH,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x43a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  HASH,ORIG_IV0,8 */
            *tp++=0x23a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  HASH,ORIG_IV0,16 */
            *tp++=0x23a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        pad_bytes_basic = EVAL_pad_bytes_basic();
        if (pad_bytes_basic > 0u)
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay */
            *tp++=0x07000000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
            /* INS CRYPTHASH,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASH */
            *tp++=0x2f020000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out ccm\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 5u)
        {
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASH, ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((aadpad)&0x1ffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+8+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST */
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((basic_hashpad)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in ccm\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 0u)
        {
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_IV1,8 */
            *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((aadpad)&0x1ffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST */
            icvlen = EVAL_icvlen();
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((basic_hashpad)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gcm\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        if (ivhandling == 0u)
        {
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
        }
        /* REMRES   bypass+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gcm\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        if (ivhandling == 0u)
        {
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
        }
        /* REMRES   bypass+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gmac\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        if (ivhandling == 5u)
        {
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT, ORIG_IV1,8 */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
        }
        /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
        *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
        /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen+8,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gmac\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        if (ivhandling == 0u)
        {
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        }
        /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypto\n");
            return TKB_BAD_PACKET;
        }
        swap_j = EVAL_swap_j();
        if (swap_j != 0u)
        {
            /* INSCTX NONE,ORIG_TOKEN,10,16 */
            *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 swap_j */
            *tp++=0x00000000 | ((swap_j)&0xffffffffu)<<0;
        }
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,8 */
        *tp++=0x22d80000 | ((8u)&0x1ffffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        /* INSCTX NONE,ORIG_TOKEN,10,16 */
        *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        /* DATA32 count */
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        if (packetsize <= bypass+srtp_offset)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP outbound\n");
            return TKB_BAD_PACKET;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR  CRYPTHASH, packetsize - bypass - srtp_offset,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR  HASH, packetsize - bypass,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* INS  HASH, ORIG_TOKEN, 4, LASTHASH ; SCTCP, index gets appended */
            *tp++=0x23da0000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
        }
        /* DATA32 srtp_swaproc */
        srtp_swaproc = EVAL_srtp_swaproc();
        *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            /* INS OUT,ORIG_SPI,4,LASTHASH */
            *tp++=0x21920000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS OUT, ORIG_HASH, icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        icvlen = EVAL_icvlen();
        extseq = EVAL_extseq();
        antireplay = EVAL_antireplay();
        if (packetsize <= bypass+srtp_offset+icvlen+extseq+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP inbound\n");
            return TKB_BAD_PACKET;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR CRYPTHASH, packetsize - bypass - srtp_offset - icvlen - extseq -antireplay,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASH, packetsize - bypass - icvlen - extseq -antireplay,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        if (extseq > 0u)
        {
            /* DIR  HASHONLY, 4, LASTHASH ; SCTCP extraxt from packet. */
            *tp++=0x02020000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 srtp_swaproc */
            srtp_swaproc = EVAL_srtp_swaproc();
            *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        }
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_SPI,4 */
            *tp++=0x40900000 | ((4u)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            /* RETR NONE,ORIG_HASH, icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY icvlen,H,SP */
                *tp++=0xd4070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* INS NONE,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x20060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY 0,SP */
                *tp++=0xd4060000 | ((0u)&0x7fu)<<0;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    default:
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
    }


    *TokenWord32Count_p = tp - (uint32_t*)Token_p;
    return TKB_STATUS_OK;
}

/* end of file token_builder_core.c */
