/****************************************************************************

                               Copyright 2010
                          Lantiq Deutschland GmbH
                   Am Campeon 3; 85579 Neubiberg, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

*****************************************************************************/
#include "ltq_cli_lib.h"
#include "gsw_cli_fkts.h"

#ifndef IOCTL_PCTOOL
#include <stdio.h>
#include "switch_cli_config.h"
#endif

const GSW_CommandTable_t cmdTable[] = {
	{/* 0 */ "GSW_8021X_EAPOL_RULE_GET", (command_fkt)gsw_8021x_eapol_rule_get},
	{/* 1 */ "GSW_8021X_EAPOL_RULE_SET", (command_fkt)gsw_8021x_eapol_rule_set},
	{/* 2 */ "GSW_8021X_PORT_CFG_GET", (command_fkt)gsw_8021x_port_cfg_get},
	{/* 3 */ "GSW_8021X_PORT_CFG_SET", (command_fkt)gsw_8021x_port_cfg_set},
	{/* 4 */ "GSW_CAP_GET", (command_fkt)gsw_cap_get},
	{/* 5 */ "GSW_CFG_GET", (command_fkt)gsw_cfg_get},
	{/* 6 */ "GSW_CFG_SET", (command_fkt)gsw_cfg_set},
	{/* 7 */ "GSW_CPU_PORT_CFG_GET", (command_fkt)gsw_cpu_port_cfg_get},
	{/* 8 */ "GSW_CPU_PORT_CFG_SET", (command_fkt)gsw_cpu_port_cfg_set},
	{/* 9 */ "GSW_CPU_PORT_EXTEND_CFG_GET", (command_fkt)gsw_cpu_port_extend_cfg_get},
	{/* 10 */ "GSW_CPU_PORT_EXTEND_CFG_SET", (command_fkt)gsw_cpu_port_extend_cfg_set},
	{/* 11 */ "GSW_DISABLE", (command_fkt)gsw_disable},
	{/* 12 */ "GSW_ENABLE", (command_fkt)gsw_enable},
	{/* 13 */ "GSW_HW_INIT", (command_fkt)gsw_hw_init},
	{/* 14 */ "GSW_MAC_TABLE_CLEAR", (command_fkt)gsw_mac_table_clear},
	{/* 15 */ "GSW_MAC_TABLE_ENTRY_ADD", (command_fkt)gsw_mac_table_entry_add},
	{/* 16 */ "GSW_MAC_TABLE_ENTRY_QUERY", (command_fkt)gsw_mac_table_entry_query},
	{/* 17 */ "GSW_MAC_TABLE_ENTRY_READ", (command_fkt)gsw_mac_table_entry_read},
	{/* 18 */ "GSW_MAC_TABLE_ENTRY_REMOVE", (command_fkt)gsw_mac_table_entry_remove},
	{/* 19 */ "GSW_MDIO_CFG_GET", (command_fkt)gsw_mdio_cfg_get},
	{/* 20 */ "GSW_MDIO_CFG_SET", (command_fkt)gsw_mdio_cfg_set},
	{/* 21 */ "GSW_MDIO_DATA_READ", (command_fkt)gsw_mdio_data_read},
	{/* 22 */ "GSW_MDIO_DATA_WRITE", (command_fkt)gsw_mdio_data_write},
	{/* 23 */ "GSW_MMD_DATA_READ", (command_fkt)gsw_mmd_data_read},
	{/* 24 */ "GSW_MMD_DATA_WRITE", (command_fkt)gsw_mmd_data_write},
	{/* 25 */ "GSW_MONITOR_PORT_CFG_GET", (command_fkt)gsw_monitor_port_cfg_get},
	{/* 26 */ "GSW_MONITOR_PORT_CFG_SET", (command_fkt)gsw_monitor_port_cfg_set},
	{/* 27 */ "GSW_MULTICAST_ROUTER_PORT_ADD", (command_fkt)gsw_multicast_router_port_add},
	{/* 28 */ "GSW_MULTICAST_ROUTER_PORT_READ", (command_fkt)gsw_multicast_router_port_read},
	{/* 29 */ "GSW_MULTICAST_ROUTER_PORT_REMOVE", (command_fkt)gsw_multicast_router_port_remove},
	{/* 30 */ "GSW_MULTICAST_SNOOP_CFG_GET", (command_fkt)gsw_multicast_snoop_cfg_get},
	{/* 31 */ "GSW_MULTICAST_SNOOP_CFG_SET", (command_fkt)gsw_multicast_snoop_cfg_set},
	{/* 32 */ "GSW_MULTICAST_TABLE_ENTRY_ADD", (command_fkt)gsw_multicast_table_entry_add},
	{/* 33 */ "GSW_MULTICAST_TABLE_ENTRY_READ", (command_fkt)gsw_multicast_table_entry_read},
	{/* 34 */ "GSW_MULTICAST_TABLE_ENTRY_REMOVE", (command_fkt)gsw_multicast_table_entry_remove},
	{/* 35 */ "GSW_PORT_CFG_GET", (command_fkt)gsw_port_cfg_get},
	{/* 36 */ "GSW_PORT_CFG_SET", (command_fkt)gsw_port_cfg_set},
	{/* 37 */ "GSW_PORT_LINK_CFG_GET", (command_fkt)gsw_port_link_cfg_get},
	{/* 38 */ "GSW_PORT_LINK_CFG_SET", (command_fkt)gsw_port_link_cfg_set},
	{/* 39 */ "GSW_PORT_PHY_ADDR_GET", (command_fkt)gsw_port_phy_addr_get},
	{/* 40 */ "GSW_PORT_PHY_QUERY", (command_fkt)gsw_port_phy_query},
	{/* 41 */ "GSW_PORT_REDIRECT_GET", (command_fkt)gsw_port_redirect_get},
	{/* 42 */ "GSW_PORT_REDIRECT_SET", (command_fkt)gsw_port_redirect_set},
	{/* 43 */ "GSW_PORT_RGMII_CLK_CFG_GET", (command_fkt)gsw_port_rgmii_clk_cfg_get},
	{/* 44 */ "GSW_PORT_RGMII_CLK_CFG_SET", (command_fkt)gsw_port_rgmii_clk_cfg_set},
	{/* 45 */ "GSW_QOS_CLASS_DSCP_GET", (command_fkt)gsw_qos_class_dscp_get},
	{/* 46 */ "GSW_QOS_CLASS_DSCP_SET", (command_fkt)gsw_qos_class_dscp_set},
	{/* 47 */ "GSW_QOS_CLASS_PCP_GET", (command_fkt)gsw_qos_class_pcp_get},
	{/* 48 */ "GSW_QOS_CLASS_PCP_SET", (command_fkt)gsw_qos_class_pcp_set},
	{/* 49 */ "GSW_QOS_DSCP_CLASS_GET", (command_fkt)gsw_qos_dscp_class_get},
	{/* 50 */ "GSW_QOS_DSCP_CLASS_SET", (command_fkt)gsw_qos_dscp_class_set},
	{/* 51 */ "GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET", (command_fkt)gsw_qos_dscp_drop_precedence_cfg_get},
	{/* 52 */ "GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET", (command_fkt)gsw_qos_dscp_drop_precedence_cfg_set},
	{/* 53 */ "GSW_QOS_METER_CFG_GET", (command_fkt)gsw_qos_meter_cfg_get},
	{/* 54 */ "GSW_QOS_METER_CFG_SET", (command_fkt)gsw_qos_meter_cfg_set},
	{/* 55 */ "GSW_QOS_METER_PORT_ASSIGN", (command_fkt)gsw_qos_meter_port_assign},
	{/* 56 */ "GSW_QOS_METER_PORT_DEASSIGN", (command_fkt)gsw_qos_meter_port_deassign},
	{/* 57 */ "GSW_QOS_METER_PORT_GET", (command_fkt)gsw_qos_meter_port_get},
	{/* 58 */ "GSW_QOS_PCP_CLASS_GET", (command_fkt)gsw_qos_pcp_class_get},
	{/* 59 */ "GSW_QOS_PCP_CLASS_SET", (command_fkt)gsw_qos_pcp_class_set},
	{/* 60 */ "GSW_QOS_PORT_CFG_GET", (command_fkt)gsw_qos_port_cfg_get},
	{/* 61 */ "GSW_QOS_PORT_CFG_SET", (command_fkt)gsw_qos_port_cfg_set},
	{/* 62 */ "GSW_QOS_PORT_REMARKING_CFG_GET", (command_fkt)gsw_qos_port_remarking_cfg_get},
	{/* 63 */ "GSW_QOS_PORT_REMARKING_CFG_SET", (command_fkt)gsw_qos_port_remarking_cfg_set},
	{/* 64 */ "GSW_QOS_QUEUE_PORT_GET", (command_fkt)gsw_qos_queue_port_get},
	{/* 65 */ "GSW_QOS_QUEUE_PORT_SET", (command_fkt)gsw_qos_queue_port_set},
	{/* 66 */ "GSW_QOS_SCHEDULER_CFG_GET", (command_fkt)gsw_qos_scheduler_cfg_get},
	{/* 67 */ "GSW_QOS_SCHEDULER_CFG_SET", (command_fkt)gsw_qos_scheduler_cfg_set},
	{/* 68 */ "GSW_QOS_SHAPER_CFG_GET", (command_fkt)gsw_qos_shaper_cfg_get},
	{/* 69 */ "GSW_QOS_SHAPER_CFG_SET", (command_fkt)gsw_qos_shaper_cfg_set},
	{/* 70 */ "GSW_QOS_SHAPER_QUEUE_ASSIGN", (command_fkt)gsw_qos_shaper_queue_assign},
	{/* 71 */ "GSW_QOS_SHAPER_QUEUE_DEASSIGN", (command_fkt)gsw_qos_shaper_queue_deassign},
	{/* 72 */ "GSW_QOS_SHAPER_QUEUE_GET", (command_fkt)gsw_qos_shaper_queue_get},
	{/* 73 */ "GSW_QOS_STORM_CFG_GET", (command_fkt)gsw_qos_storm_cfg_get},
	{/* 74 */ "GSW_QOS_STORM_CFG_SET", (command_fkt)gsw_qos_storm_cfg_set},
	{/* 75 */ "GSW_QOS_WRED_CFG_GET", (command_fkt)gsw_qos_wred_cfg_get},
	{/* 76 */ "GSW_QOS_WRED_CFG_SET", (command_fkt)gsw_qos_wred_cfg_set},
	{/* 77 */ "GSW_QOS_WRED_QUEUE_CFG_GET", (command_fkt)gsw_qos_wred_queue_cfg_get},
	{/* 78 */ "GSW_QOS_WRED_QUEUE_CFG_SET", (command_fkt)gsw_qos_wred_queue_cfg_set},
	{/* 79 */ "GSW_RMON_CLEAR", (command_fkt)gsw_rmon_clear},
	{/* 80 */ "GSW_RMON_PORT_GET", (command_fkt)gsw_rmon_port_get},
	{/* 81 */ "GSW_STP_BPDU_RULE_GET", (command_fkt)gsw_stp_bpdu_rule_get},
	{/* 82 */ "GSW_STP_BPDU_RULE_SET", (command_fkt)gsw_stp_bpdu_rule_set},
	{/* 83 */ "GSW_STP_PORT_CFG_GET", (command_fkt)gsw_stp_port_cfg_get},
	{/* 84 */ "GSW_STP_PORT_CFG_SET", (command_fkt)gsw_stp_port_cfg_set},
	{/* 85 */ "GSW_VERSION_GET", (command_fkt)gsw_version_get},
	{/* 86 */ "GSW_VLAN_ID_CREATE", (command_fkt)gsw_vlan_id_create},
	{/* 87 */ "GSW_VLAN_ID_DELETE", (command_fkt)gsw_vlan_id_delete},
	{/* 88 */ "GSW_VLAN_ID_GET", (command_fkt)gsw_vlan_id_get},
	{/* 89 */ "GSW_VLAN_PORT_CFG_GET", (command_fkt)gsw_vlan_port_cfg_get},
	{/* 90 */ "GSW_VLAN_PORT_CFG_SET", (command_fkt)gsw_vlan_port_cfg_set},
	{/* 91 */ "GSW_VLAN_PORT_MEMBER_ADD", (command_fkt)gsw_vlan_port_member_add},
	{/* 92 */ "GSW_VLAN_PORT_MEMBER_READ", (command_fkt)gsw_vlan_port_member_read},
	{/* 93 */ "GSW_VLAN_PORT_MEMBER_REMOVE", (command_fkt)gsw_vlan_port_member_remove},
	{/* 94 */ "GSW_VLAN_MEMBER_INIT", (command_fkt)gsw_vlan_member_init},
	{/* 95 */ "GSW_VLAN_RESERVED_ADD", (command_fkt)gsw_vlan_reserved_add},
	{/* 96 */ "GSW_VLAN_RESERVED_REMOVE", (command_fkt)gsw_vlan_reserved_remove},
	{/* 97 */ "GSW_WOL_CFG_GET", (command_fkt)gsw_wol_cfg_get},
	{/* 98 */ "GSW_WOL_CFG_SET", (command_fkt)gsw_wol_cfg_set},
	{/* 99 */ "GSW_WOL_PORT_CFG_GET", (command_fkt)gsw_wol_port_cfg_get},
	{/* 100*/ "GSW_WOL_PORT_CFG_SET", (command_fkt)gsw_wol_port_cfg_set},
	{/* 101 */ "GSW_IRQ_GET", (command_fkt)gsw_irq_get},
	{/* 102 */ "GSW_IRQ_MASK_GET", (command_fkt)gsw_irq_mask_get},
	{/* 103 */ "GSW_IRQ_MASK_SET", (command_fkt)gsw_irq_mask_set},
	{/* 104 */ "GSW_IRQ_STATUS_CLEAR", (command_fkt)gsw_irq_status_clear},
	{/* 105 */ "GSW_PCE_RULE_DELETE", (command_fkt)gsw_pce_rule_delete},
	{/* 106 */ "GSW_PCE_RULE_READ", (command_fkt)gsw_pce_rule_read},
	{/* 107 */ "GSW_PCE_RULE_WRITE", (command_fkt)gsw_pce_rule_write},
	{/* 108 */ "GSW_REGISTER_GET", (command_fkt)gsw_register_get},
	{/* 109 */ "GSW_REGISTER_SET", (command_fkt)gsw_register_set},
	{/* 110 */ "GSW_RESET", (command_fkt)gsw_reset},
	{/* 111 */ "GSW_RMON_EXTEND_GET", (command_fkt)gsw_rmon_extend_get},
	{/* 112 */ "GSW_TIMESTAMP_TIMER_GET", (command_fkt)gsw_timestamp_timer_get},
	{/* 113 */ "GSW_TIMESTAMP_TIMER_SET", (command_fkt)gsw_timestamp_timer_set},
	{/* 114 */ "GSW_TIMESTAMP_PORT_READ", (command_fkt)gsw_timestamp_port_read},
	{/* 115 */ "GSW_TRUNKING_CFG_GET", (command_fkt)gsw_trunking_cfg_get},
	{/* 116 */ "GSW_TRUNKING_CFG_SET", (command_fkt)gsw_trunking_cfg_set},
	{/* 117 */ "GSW_TRUNKING_PORT_CFG_GET", (command_fkt)gsw_trunking_port_cfg_get},
	{/* 118 */ "GSW_TRUNKING_PORT_CFG_SET", (command_fkt)gsw_trunking_port_cfg_set},
	{/* 119 */ "GSW_QOS_WRED_PORT_CFG_GET", (command_fkt)gsw_qos_wred_port_cfg_get},
	{/* 120 */ "GSW_QOS_WRED_PORT_CFG_SET", (command_fkt)gsw_qos_wred_port_cfg_set},
	{/* 121 */ "GSW_QOS_FLOWCTRL_CFG_GET", (command_fkt)gsw_qos_flowctrl_cfg_get},
	{/* 122 */ "GSW_QOS_FLOWCTRL_CFG_SET", (command_fkt)gsw_qos_flowctrl_cfg_set},
	{/* 123 */ "GSW_QOS_FLOWCTRL_PORT_CFG_GET", (command_fkt)gsw_qos_flowctrl_port_cfg_get},
	{/* 124 */ "GSW_QOS_FLOWCTRL_PORT_CFG_SET", (command_fkt)gsw_qos_flowctrl_port_cfg_set},
	{/* 125 */ "GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET", (command_fkt)gsw_qos_queue_buffer_reserve_cfg_get},
	{/* 126 */ "GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET", (command_fkt)gsw_qos_queue_buffer_reserve_cfg_set},

	{/* 127 */ "GSW_SVLAN_CFG_GET", (command_fkt)gsw_svlan_cfg_get},
	{/* 128 */ "GSW_SVLAN_CFG_SET", (command_fkt)gsw_svlan_cfg_set},
	{/* 129 */ "GSW_SVLAN_PORT_CFG_GET", (command_fkt)gsw_svlan_port_cfg_get},
	{/* 130 */ "GSW_SVLAN_PORT_CFG_SET", (command_fkt)gsw_svlan_port_cfg_set},
	{/* 131 */ "GSW_QOS_SVLAN_CLASS_PCP_PORT_GET", (command_fkt)gsw_qos_svlan_class_pcp_port_get},
	{/* 132 */ "GSW_QOS_SVLAN_CLASS_PCP_PORT_SET", (command_fkt)gsw_qos_svlan_class_pcp_port_set},
	{/* 133 */ "GSW_QOS_SVLAN_PCP_CLASS_GET", (command_fkt)gsw_qos_svlan_pcp_class_get},
	{/* 134 */ "GSW_QOS_SVLAN_PCP_CLASS_SET", (command_fkt)gsw_qos_svlan_pcp_class_set},
	{/* 135 */ "GSW_PCE_EG_VLAN_CFG_SET", (command_fkt)gsw_pce_eg_vlan_cfg_set},
	{/* 136 */ "GSW_PCE_EG_VLAN_CFG_GET", (command_fkt)gsw_pce_eg_vlan_cfg_get},
	{/* 137 */ "GSW_PCE_EG_VLAN_ENTRY_WRITE", (command_fkt)gsw_pce_eg_vlan_entry_write},
	{/* 138 */ "GSW_PCE_EG_VLAN_ENTRY_READ", (command_fkt)gsw_pce_eg_vlan_entry_read},
	{/* 139 */ "GSW_PMAC_BM_CFG_GET", (command_fkt)gsw_pmac_bm_cfg_get},
	{/* 140 */ "GSW_PMAC_EG_CFG_GET", (command_fkt)gsw_pmac_eg_cfg_get},
	{/* 141 */ "GSW_PMAC_IG_CFG_GET", (command_fkt)gsw_pmac_ig_cfg_get},
	{/* 142 */ "GSW_PMAC_COUNT_GET", (command_fkt)gsw_pmac_count_get},
	{/* 143 */ "GSW_RMON_MODE_SET", (command_fkt)gsw_rmon_mode_set},
	{/* 144 */ "GSW_RMON_IF_GET", (command_fkt)gsw_rmon_if_get},
	{/* 145 */ "GSW_RMON_REDIRECT_GET", (command_fkt)gsw_rmon_redirect_get},
	{/* 146 */ "GSW_RMON_ROUTE_GET", (command_fkt)gsw_rmon_route_get},
	{/* 147 */ "GSW_RMON_METER_GET", (command_fkt)gsw_rmon_meter_get},
	{/* 148 */ "GSW_QOS_METER_ACT", (command_fkt)gsw_qos_meter_act},
	{/* 149 */ "GSW_PMAC_GLBL_CFG_SET", (command_fkt)gsw_pmac_glbl_cfg_set},
	{/* 150 */ "GSW_PMAC_GLBL_CFG_GET", (command_fkt)gsw_pmac_glbl_cfg_get},

#if defined(CONFIG_LTQ_TEST) && CONFIG_LTQ_TEST
	{/* 152 */ "GSW_ROUTE_ENTRY_READ", (command_fkt)gsw_route_entry_read},
	{/* 153 */ "GSW_ROUTE_ENTRY_DELETE", (command_fkt)gsw_route_entry_delete},
	{/* 154 */ "GSW_ROUTE_ENTRY_ADD", (command_fkt)gsw_route_entry_add},
	{/* 155 */ "GSW_ROUTE_TUNNEL_ENTRY_READ", (command_fkt)gsw_route_tunnel_entry_read},
	{/* 156 */ "GSW_ROUTE_TUNNEL_ENTRY_DELETE", (command_fkt)gsw_route_tunnel_entry_delete},
	{/* 157 */ "GSW_ROUTE_TUNNEL_ENTRY_ADD", (command_fkt)gsw_route_tunnel_entry_add},
	{/* 158 */ "GSW_ROUTE_L2NAT_CFG_READ", (command_fkt)gsw_route_l2nat_cfg_read},
	{/* 159 */ "GSW_ROUTE_L2NAT_CFG_WRITE", (command_fkt)gsw_route_l2nat_cfg_write},
	{/* 160 */ "GSW_ROUTE_SESSION_HIT_OP", (command_fkt)gsw_route_session_hit_op},
	{/* 161 */ "GSW_ROUTE_SESSION_DEST_MOD", (command_fkt)gsw_route_session_dest_mod},

#endif

	{/* 162 */ "GSW_CTP_PORT_ASSIGNMENT_SET", (command_fkt)gsw_ctp_port_assigment_set},
	{/* 163 */ "GSW_CTP_PORT_ASSIGNMENT_GET", (command_fkt)gsw_ctp_port_assigment_get},
	{/* 164 */ "GSW_EXTENDEDVLAN_SET", (command_fkt)gsw_extendedvlan_config_set},
	{/* 165 */ "GSW_EXTENDEDVLAN_GET", (command_fkt)gsw_extendedvlan_config_get},
	{/* 166 */ "GSW_EXTENDEDVLAN_FREE", (command_fkt)gsw_extendedvlan_free},
	{/* 167 */ "GSW_VLANFILTER_SET", (command_fkt)gsw_vlanfilter_config_set},
	{/* 168 */ "GSW_VLANFILTER_GET", (command_fkt)gsw_vlanfilter_config_get},
	{/* 169 */ "GSW_VLANFILTER_FREE", (command_fkt)gsw_vlanfilter_free},
	{/* 170 */ "GSW_BRIDGE_CONFIG_SET", (command_fkt)gsw_bridge_config_set},
	{/* 171 */ "GSW_BRIDGE_CONFIG_GET", (command_fkt)gsw_bridge_config_get},
	{/* 172 */ "GSW_BRIDGE_FREE", (command_fkt)gsw_bridge_free},
	{/* 173 */ "GSW_CTP_PORT_CONFIG_SET", (command_fkt)gsw_ctp_port_config_set},
	{/* 174 */ "GSW_CTP_PORT_CONFIG_GET", (command_fkt)gsw_ctp_port_config_get},
	{/* 175 */ "GSW_CTP_PORT_CONFIG_RESET", (command_fkt)gsw_ctp_port_config_reset},
	{/* 176 */ "GSW_BRIDGE_PORT_CONFIG_SET", (command_fkt)gsw_bridge_port_config_set},
	{/* 177 */ "GSW_BRIDGE_PORT_CONFIG_GET", (command_fkt)gsw_bridge_port_config_get},
	{/* 178 */ "GSW_BRIDGE_PORT_ALLOC", (command_fkt)gsw_bridge_port_alloc},
	{/* 179 */ "GSW_BRIDGE_PORT_FREE", (command_fkt)gsw_bridge_port_free},
	{/* 180 */ "GSW_EXTENDEDVLAN_ALLOC", (command_fkt)gsw_extendedvlan_alloc},
	{/* 181 */ "GSW_VLANFILTER_ALLOC", (command_fkt)gsw_vlanfilter_alloc},
	{/* 182 */ "GSW_BRIDGE_ALLOC", (command_fkt)gsw_bridge_alloc},
	{/* 183 */ "GSW_PMAC_RMON_GET", (command_fkt)gsw_pmac_rmon_get},

	{/* 184 */ "GSW_DEBUG_CTPTABLE_STATUS", (command_fkt)gsw_debug_ctptablestatus},
	{/* 185 */ "GSW_DEBUG_BRDGPORTTABLE_STATUS", (command_fkt)gsw_debug_bridgeporttablestatus},
	{/* 186 */ "GSW_DEBUG_BRDGTABLE_STATUS", (command_fkt)gsw_debug_bridgetablestatus},
	{/* 187 */ "GSW_DEBUG_EXVLANTABLE_STATUS", (command_fkt)gsw_debug_Exvlantablestatus},
	{/* 188 */ "GSW_DEBUG_VLANFILTERTABLE_STATUS", (command_fkt)gsw_debug_VlanFiltertablestatus},
	{/* 189 */ "GSW_DEBUG_METERTABLE_STATUS", (command_fkt)gsw_debug_Metertablestatus},
	{/* 190 */ "GSW_DEBUG_DSCP2PCPTABLE_STATUS", (command_fkt)gsw_debug_Dscp2Pcptablestatus},
	{/* 191 */ "GSW_DEBUG_PMAPPER_STATUS", (command_fkt)gsw_debug_Pmappertablestatus},
	{/* 192 */ "GSW_DEBUG_PMAC_EG", (command_fkt)gsw_debug_pmac_eg},
	{/* 193 */ "GSW_DEBUG_PMAC_IG", (command_fkt)gsw_debug_pmac_ig},
	{/* 194 */ "GSW_DEBUG_PMAC_BP", (command_fkt)gsw_debug_pmac_bp},
	{/* 195 */ "GSW_DEBUG_DEF_QMAP", (command_fkt)gsw_debug_def_pce_qmap},
	{/* 196 */ "GSW_DEBUG_DEF_BYP_QMAP", (command_fkt)gsw_debug_def_byp_qmap},
	{/* 197 */ "xgmac", (command_fkt)gsw_xgmac_cli},
	{/* 198 */ "GSW_PMAC_BM_CFG_SET", (command_fkt)gsw_pmac_bm_cfg_set},
	{/* 199 */ "GSW_PMAC_EG_CFG_SET", (command_fkt)gsw_pmac_eg_cfg_set},
	{/* 200 */ "GSW_PMAC_IG_CFG_SET", (command_fkt)gsw_pmac_ig_cfg_set},
	{/* 201 */ "GSW_DEBUG_CTP_STATISTICS", (command_fkt)gsw_debug_ctpstatistics},
	{/* 202 */ "GSW_DEBUG_LP_STATISTICS", (command_fkt)gsw_debug_lpstatistics},
	{/* 203 */ "gswss", (command_fkt)gsw_gswss_cli},
	{/* 204 */ "lmac", (command_fkt)gsw_lmac_cli},
	{/* 205 */ "GSW_CTP_PORT_ASSIGNMENT_ALLOC", (command_fkt)gsw_ctp_port_alloc},
	{/* 206 */ "GSW_CTP_PORT_ASSIGNMENT_FREE", (command_fkt)gsw_ctp_port_free},
	{/* 207 */ "macsec", (command_fkt)gsw_macsec_cli},
	{/* 208 */ "GSW_IRQ_REGISTER", (command_fkt)gsw_irq_register},
	{/* 209 */ "GSW_IRQ_UNREGISTER", (command_fkt)gsw_irq_unregister},
	{/* 210 */ "GSW_IRQ_ENABLE", (command_fkt)gsw_irq_enable},
	{/* 211 */ "GSW_IRQ_DISBALE", (command_fkt)gsw_irq_disable},
	{/* 212 */ "GSW_DEBUG_PRINT_PCEIRQ_LIST", (command_fkt)gsw_debug_PrintPceIrqList},
	{/* 213 */ "GSW_RMON_FLOW_GET", (command_fkt)gsw_rmon_flow_get},
	{/* 214 */ "GSW_RMON_TFLOW_CLEAR", (command_fkt)gsw_rmon_tflow_clear},
	{/* 215 */ "GSW_DSCP2PCP_MAP_GET", (command_fkt)gsw_dscp2pcp_map_get},
	{/* 216 */ "GSW_DEFAUL_MAC_FILTER_GET", (command_fkt)gsw_defaul_mac_filter_get},
	{/* 217 */ "GSW_DEFAUL_MAC_FILTER_SET", (command_fkt)gsw_defaul_mac_filter_set},
	{/* 218 */ "GSW_QOS_COLOR_MARKING_TABLE_SET", (command_fkt)gsw_qos_color_marking_table_set},
	{/* 219 */ "GSW_QOS_COLOR_MARKING_TABLE_GET", (command_fkt)gsw_qos_color_marking_table_get},
	{/* 220 */ "GSW_QOS_COLOR_REMARKING_TABLE_GET", (command_fkt)gsw_qos_color_remarking_table_get},
	{/* 221 */ "GSW_QOS_COLOR_REMARKING_TABLE_SET", (command_fkt)gsw_qos_color_remarking_table_set},


	{/* 222 */ "GSW_DEBUG_RMON_PORT_GET", (command_fkt)gsw_debug_rmon_port_get},
	{/* 223 */ "GSW_CTP_PORT_RMON_GET", (command_fkt)gsw_debug_ctp_rmon_port_get},
	{/* 224 */ "GSW_BRIDGE_PORT_RMON_GET", (command_fkt)gsw_debug_bridge_rmon_port_get},
	{/* 225 */ "GSW_CTP_PORT_PCEBYPASS_RMON_GET", (command_fkt)gsw_debug_ctpbypass_rmon_port_get},

	{/* 226 */ "GSW_DEBUG_RMON_ALL_GET", (command_fkt)gsw_debug_rmon_port_get_all},

	{/* 227 */ "GSW_PBB_TUNNEL_TEMPLATE_ALLOC", (command_fkt)gsw_pbb_tunneltemplate_alloc},
	{/* 228 */ "GSW_PBB_TUNNEL_TEMPLATE_FREE", (command_fkt)gsw_pbb_tunneltemplate_free},
	{/* 229 */ "GSW_PBB_TUNNEL_TEMPLATE_SET", (command_fkt)gsw_pbb_tunneltemplate_config_set},
	{/* 230 */ "GSW_PBB_TUNNEL_TEMPLATE_GET", (command_fkt)gsw_pbb_tunneltemplate_config_get},

	{/* 231 */ "GSW_DEBUG_TUNNELTEMP_STATUS", (command_fkt)gsw_debug_tunneltemptablestatus},
	{/* 232 */ "pmac_br", (command_fkt)gsw_pmacbr_cli},

	{/* 233 */ "GSW_LPID_TO_GPID_ASSIGNMENT_SET", (command_fkt)gsw_lpidTogpid_assignmentset},
	{/* 234 */ "GSW_LPID_TO_GPID_ASSIGNMENT_GET", (command_fkt)gsw_lpidTogpid_assignmentget},
	{/* 235 */ "GSW_GPID_TO_LPID_ASSIGNMENT_SET", (command_fkt)gsw_gpidTolpid_assignmentset},
	{/* 236 */ "GSW_GPID_TO_LPID_ASSIGNMENT_GET", (command_fkt)gsw_gpidTolpid_assignmentget},
	{/* 237 */ "GSW_DUMP_MEM", (command_fkt)gsw_dump_mem},
	{/* 238 */ "GSW_DEFAUL_PCE_QMAP_GET", (command_fkt)gsw_defaul_pce_qmap_get},
	{/* 239 */ "GSW_DEFAUL_PCE_BYPASS_QMAP_GET", (command_fkt)gsw_defaul_bypass_qmap_get},
	{/* 240 */ "GSW_IG_CFG_PMAC_GET", (command_fkt)gsw_pmac_get_ig_cfg},
	{/* 241 */ "GSW_DEBUG_PMAC_RMON_GET_ALL", (command_fkt)gsw_debug_pmac_rmon_get_all},
	{/* 242 */ "GSW_PCE_RULE_ALLOC", (command_fkt)gsw_pce_rule_alloc},
	{/* 243 */ "GSW_PCE_RULE_FREE", (command_fkt)gsw_pce_rule_free},
	{/* 244 */ "GSW_DEBUG_PCERULETABLE_STATUS", (command_fkt)gsw_debug_pceruletablestatus},
	{/* 245 */ "GSW_VXLAN_CFG_SET", (command_fkt)gsw_vxlan_cfg_uset},
	{/* 246 */ "GSW_VXLAN_CFG_GET", (command_fkt)gsw_vxlan_cfg_uget},
	{/* 247 */ "GSW_READ_PCE_TABLE", (command_fkt)gsw_read_all_enabled_pce_rule},
	{/* 248 */ "GSW_QOS_METER_ALLOC", (command_fkt)gsw_qos_meter_alloc},
	{/* 249 */ "GSW_QOS_METER_FREE", (command_fkt)gsw_qos_meter_free},
	{/* 250 */ "GSW_PCE_RULE_ENABLE", (command_fkt)gsw_pce_rule_enable},
	{/* 251 */ "GSW_PCE_RULE_DISABLE", (command_fkt)gsw_pce_rule_disable},

	{NULL, NULL},
};


//#ifdef SWITCHAPI_HELP_TEXT
const char *const HelpText[] = {
	/* 0: GSW_8021X_EAPOL_RULE_GET */
	"Read the IEEE 802.1x filter configuration. The parameters can be modified\n"
	"using GSW_8021X_EAPOL_RULE_SET.",
	/* 1: GSW_8021X_EAPOL_RULE_SET */
	"Set the IEEE 802.1x filter rule for a dedicated port. Filtered packets can be\n"
	"redirected to one dedicated port (e.g. CPU port). The switch supports the\n"
	"addition of a specific packet header to the filtered packets that contains\n"
	"information like source port, priority and so on. The parameters can be read\n"
	"using GSW_8021X_EAPOL_RULE_GET.\n"
	"\nParameter:\n----------\n"
	"eForwardPort :\n"
	"\tFilter authentication packets and forward them, discard them or\n"
	"\tdisable the filter.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Default; portmap is determined by the forwarding classification.\n"
	"\n"
	"\t1: Discard; discard packets.\n"
	"\n"
	"\t2: Forward to the CPU port. This requires that the CPU port is\n"
	"\t\tpreviously set by calling GSW_CPU_PORT_CFG_SET.\n"
	"\n"
	"\t3: Forward to a port, selected by the parameter 'nForwardPortId'.\n"
	"\t\tPlease note that this feature is not supported by all hardware\n"
	"\t\tplatforms.\n"
	"\n"
	"nForwardPortId :\n"
	"\tTarget port for forwarded packets, only used if selected by\n"
	"\t'eForwardPort'. Forwarding is done if 'eForwardPort =\n"
	"\tGSW_PORT_FORWARD_PORT'.",
	/* 2: GSW_8021X_PORT_CFG_GET */
	"Get the 802.1x port status for a switch port. A configuration can be set using\n"
	"GSW_8021X_PORT_CFG_SET\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 3: GSW_8021X_PORT_CFG_SET */
	"Set the 802.1x port status for a switch port. The port configuration can be\n"
	"read using GSW_8021X_PORT_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"eState :\n"
	"\t802.1x state of the port.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Receive and transmit direction are authorized. The port is allowed\n"
	"\t\tto transmit and receive all packets and the address learning\n"
	"\t\tprocess is also allowed.\n"
	"\n"
	"\t1: Receive and transmit direction are unauthorized. All the packets\n"
	"\t\texcept EAPOL are not allowed to transmit and receive. The address\n"
	"\t\tlearning process is disabled.\n"
	"\n"
	"\t2: Receive direction is authorized, transmit direction is\n"
	"\t\tunauthorized. The port is allowed to receive all packets. Packet\n"
	"\t\ttransmission to this port is not allowed. The address learning\n"
	"\t\tprocess is also allowed.\n"
	"\n"
	"\t3: Transmit direction is authorized, receive direction is\n"
	"\t\tunauthorized. The port is allowed to transmit all packets. Packet\n"
	"\t\treception on this port is not allowed. The address learning process\n"
	"\t\tis disabled.",
	/* 4: GSW_CAP_GET */
	"This service returns the capability referenced by the provided index\n"
	"(zero-based counting index value). The Switch API uses the index to return the\n"
	"capability parameter from an internal list. For instance, the capability list\n"
	"contains information about the amount of supported features like number of\n"
	"supported VLAN groups or MAC table entries. The command returns zero-length\n"
	"strings ('') in case the requested index number is out of range.",
	/* 5: GSW_CFG_GET */
	"Read the global switch configuration. This configuration can be set using\n"
	"GSW_CFG_SET.",
	/* 6: GSW_CFG_SET */
	"Modify the switch configuration. The configuration can be read using\n"
	"GSW_CFG_GET. The switch can be enabled using GSW_ENABLE.\n"
	"\nParameter:\n----------\n"
	"eMAC_TableAgeTimer :\n"
	"\tMAC table aging timer. After this timer expires the MAC table entry is\n"
	"\taged out.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t1: 1 second\n"
	"\n"
	"\t2: 10 seconds\n"
	"\n"
	"\t3: 300 seconds\n"
	"\n"
	"\t4: 1 hour\n"
	"\n"
	"\t5: 24 hours\n"
	"\n"
	"\t6: seconds in parameter nAgeTimer\n"
	"\n"
	"nAgeTimer :\n"
	"\tAge timer in seconds.\n"
	"\n"
	"bVLAN_Aware :\n"
	"\tVLAN Awareness. The switch is VLAN unaware if this variable is\n"
	"\tdisabled. In this mode, no VLAN-related APIs are supported and return\n"
	"\twith an error. The existing VLAN configuration is discarded when VLAN\n"
	"\tis disabled again.\n"
	"\n"
	"nMaxPacketLen :\n"
	"\tMaximum Ethernet packet length.\n"
	"\n"
	"bLearningLimitAction :\n"
	"\tAutomatic MAC address table learning limitation consecutive action.\n"
	"\tThese frame addresses are not learned, but there exists control as to\n"
	"\twhether the frame is still forwarded or dropped. - 0: Drop -\n"
	"\t1: Forward\n"
	"\n"
	"bMAC_SpoofingAction :\n"
	"\tAccept or discard MAC spoofing and port MAC locking violation packets.\n"
	"\ta MAC source address which was previously learned on a different\n"
	"\tingress port (learned by MAC bridging table). This also applies to\n"
	"\tstatic added entries. MAC spoofing detection is enabled on port level \n"
	"\tby 'bMAC_SpoofingDetection'. MAC address port locking is configured on port level\n"
	"\tby 'bLearningMAC_PortLock'. IFX_FALSE(0): Drop,IFX_TRUE(1): Forward \n"
	"\n"
	"bPauseMAC_ModeSrc :\n"
	"\tPause frame MAC source address mode. If enabled, use the alternative\n"
	"\taddress specified with 'nMAC'.\n"
	"\n"
	"nPauseMAC_Src :\n"
	"\tPause frame MAC source address.\n"
	"\tSupported Formats: 12:34:45:67:89:0A",
	/* 7: GSW_CPU_PORT_CFG_GET */
	"Get the port that is directly connected to the software running on a CPU and\n"
	"defined as CPU port. This port assignment can be set using\n"
	"GSW_CPU_PORT_CFG_SET if it is not fixed and defined by the switch device\n"
	"architecture.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 8: GSW_CPU_PORT_CFG_SET */
	"Defines one port that is directly connected to the software running on a CPU.\n"
	"This allows for the redirecting of protocol-specific packets to the CPU port\n"
	"and special packet treatment when sent by the CPU. If the CPU port cannot be\n"
	"set, the function returns an error code.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bCPU_PortValid :\n"
	"\tCPU port validity. Set command: set true to define a CPU port, set\n"
	"\tfalse to undo the setting. Get command: true if defined as CPU, false\n"
	"\tif not defined as CPU port.\n"
	"\n"
	"bSpecialTagIngress :\n"
	"\tSpecial tag enable in ingress direction.\n"
	"\n"
	"bSpecialTagEgress :\n"
	"\tSpecial tag enable in egress direction.\n"
	"\n"
	"bFcsCheck :\n"
	"\tEnable FCS check - 0: No check, forward all frames - 1:\n"
	"\tCheck FCS, drop frames with errors\n"
	"\n"
	"bFcsGenerate :\n"
	"\tEnable FCS generation - 0: Forward packets without FCS -\n"
	"\t1: Generate FCS for all frames\n"
	"\n"
	"bSpecialTagEthType :\n"
	"\tSpecial tag Ethertype mode.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: The EtherType field of the Special Tag of egress packets is always\n"
	"\t\tset to a prefined value. This same defined value applies for all\n"
	"\t\tswitch ports.\n"
	"\n"
	"\t1: The Ethertype field of the Special Tag of egress packets is set to\n"
	"\t\tthe FlowID parameter, which is a results of the switch flow\n"
	"\t\tclassification result. The switch flow table rule provides this\n"
	"\t\tFlowID as action parameter."

	"eNoMPEParserCfg :\n"
	"\tParser Header Config for no MPE flags (i.e. MPE1=0, MPE2=0).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Parsing Results are not carried on the traffic to CPU port \n"
	"\t\t(both MPE1 and MPE2 flags are not set. \n"
	"\t1: 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination. \n"
	"\t2: 40-Bytes Offsets (Offset-0 to -39) + 8-Bytes Parsing Flags (Bit 63:0) \n"
	"\t\t accompanying to CPU Port for this combination \n"
	"\t3: Reserved - for future use \n"
	"\n"
	"eMPE1ParserCfg :\n"
	"\tParser Header Config for MPE-1 set flag (i.e. MPE1=1, MPE2=0).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Parsing Results are not carried on the traffic to CPU port \n"
	"\t\t(both MPE1 and MPE2 flags are not set. \n"
	"\t1: 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination. \n"
	"\t2: 40-Bytes Offsets (Offset-0 to -39) + 8-Bytes Parsing Flags (Bit 63:0) \n"
	"\t\t accompanying to CPU Port for this combination \n"
	"\t3: Reserved - for future use \n"
	"\n"
	"eMPE2ParserCfg :\n"
	"\tParser Header Config for MPE-2 set flag (i.e. MPE1=0, MPE2=1).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Parsing Results are not carried on the traffic to CPU port \n"
	"\t\t(both MPE1 and MPE2 flags are not set. \n"
	"\t1: 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination. \n"
	"\t2: 40-Bytes Offsets (Offset-0 to -39) + 8-Bytes Parsing Flags (Bit 63:0) \n"
	"\t\t accompanying to CPU Port for this combination \n"
	"\t3: Reserved - for future use \n"
	"\n"
	"eMPE1MPE2ParserCfg :\n"
	"\tParser Header Config for both MPE-1 and MPE-2 set flag (i.e. MPE1=1, MPE2=1).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Parsing Results are not carried on the traffic to CPU port \n"
	"\t\t(both MPE1 and MPE2 flags are not set. \n"
	"\t1: 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination. \n"
	"\t2: 40-Bytes Offsets (Offset-0 to -39) + 8-Bytes Parsing Flags (Bit 63:0) \n"
	"\t\t accompanying to CPU Port for this combination \n"
	"\t3: Reserved - for future use \n"
	"\n"
	"\n",
	/* 9: GSW_CPU_PORT_EXTEND_CFG_GET */
	"Reads out additional CPU port configuration. This configuration applies to\n"
	"devices where the CPU port is fixed to one dedicated port.",
	/* 10: GSW_CPU_PORT_EXTEND_CFG_SET */
	"Configure an additional CPU port configuration. This configuration applies to\n"
	"devices where the CPU port is fixed to one dedicated port.\n"
	"\nParameter:\n----------\n"
	"eHeaderAdd :\n"
	"\tAdd Ethernet layer-2 header (also VLAN) to the transmit packet. The\n"
	"\tcorresponding header fields are set in 'sHeader'.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No additional Ethernet header.\n"
	"\n"
	"\t1: Additional Ethernet header.\n"
	"\n"
	"\t2: Additional Ethernet- and VLAN- header.\n"
	"\n"
	"bHeaderRemove :\n"
	"\tRemove Ethernet layer-2 header (also VLAN) for packets going from\n"
	"\tEthernet switch to the DMA. Only the first VLAN tag found is removed\n"
	"\tand additional available VLAN tags remain untouched.\n"
	"\n"
	"Ethernet layer-2 header information. Used when adding a header to the\n"
	"transmitted packet. The parameter 'eHeaderAdd' selects the mode if a layer-2\n"
	"header should be added (including VLAN). This structure contains all fields of\n"
	"the Ethernet and VLAN header.\n"
	"sHeader.nMAC_Src :\n"
	"\tPacket MAC Source Address.\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"sHeader.nMAC_Dst :\n"
	"\tPacket MAC Destination Address.\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"sHeader.nEthertype :\n"
	"\tPacket EtherType Field.\n"
	"\n"
	"sHeader.nVLAN_Prio :\n"
	"\tVLAN Tag Priority Field. Only used when adding VLAN tag is enabled\n"
	"\t(eHeaderAdd=GSW_CPU_HEADER_VLAN).\n"
	"\n"
	"sHeader.nVLAN_CFI :\n"
	"\tVLAN Tag Canonical Format Identifier. Only used when adding VLAN tag\n"
	"\tis enabled (eHeaderAdd=GSW_CPU_HEADER_VLAN).\n"
	"\n"
	"sHeader.nVLAN_ID :\n"
	"\tVLAN Tag VLAN ID. Only used when adding VLAN tag is enabled\n"
	"\t(eHeaderAdd=GSW_CPU_HEADER_VLAN).\n"
	"\n"
	"ePauseCtrl :\n"
	"\tDescribes how the port handles received PAUSE frames coming from the\n"
	"\tswitch. Either forward them to DMA or stop/start transmission. Note\n"
	"\tthat the parameter 'eFlowCtrl' of the command 'GSW_PORT_CFG_SET'\n"
	"\tdetermines whether the switch generates PAUSE frames.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Forward all PAUSE frames coming from the switch macro towards the\n"
	"\t\tDMA channel. These frames do not influence the packet transmission.\n"
	"\n"
	"\t1: Dispatch all PAUSE frames coming from the switch macro towards the\n"
	"\t\tDMA channel. These are filtered out and the packets transmission is\n"
	"\t\tstopped and restarted accordingly.\n"
	"\n"
	"bFcsRemove :\n"
	"\tRemove the CRC (FCS) of all packets coming from the switch towards the\n"
	"\tDMA channel. Note that the FCS check and generation option can be\n"
	"\tconfigured using 'GSW_CPU_PORT_CFG_SET'.\n"
	"\n"
	"nWAN_Ports :\n"
	"\tPort map of Ethernet switch ports that are assigned to the WAN side\n"
	"\t(dedicated for applications where ports are grouped into WAN- and LAN-\n"
	"\tsegments). All ports that are not selected belong to the LAN segment.\n"
	"\tThe LSB bit represents port 0, the higher bits represent the higher\n"
	"\tport numbers.",
	/* 11: GSW_DISABLE */
	"Disables the whole switch. The switch can be enabled using the\n"
	"GSW_ENABLE command",
	/* 12: GSW_ENABLE */
	"Enables the whole switch. The switch device is enabled with the default\n"
	"configuration in case no other configuration is applied. The switch can be\n"
	"disabled using the GSW_DISABLE command",
	/* 13: GSW_HW_INIT */
	"Hardware Initialization. This command should be called right after the Switch\n"
	"API software module is initialized and loaded. It accesses the hardware\n"
	"platform, retrieving platform capabilities and performing the first basic\n"
	"configuration.\n"
	"\nParameter:\n----------\n"
	"eInitMode :\n"
	"\tSelect the type of Switch API and hardware initialization.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Access the switch hardware to read out status and capability\n"
	"\t\tinformation. Then define the basic hardware configuration to bring\n"
	"\t\tthe hardware into a pre-defined state.\n"
	"\n"
	"\t1: Access the switch hardware to read out status and capability\n"
	"\t\tinformation. Do not write any hardware configuration to the device.\n"
	"\t\tThis means that the current existing hardware configuration remains\n"
	"\t\tunchanged.\n"
	"\n"
	"\t2: Initialize the switch software module but do not touch the switch\n"
	"\t\thardware. This means that no read or write operations are done on\n"
	"\t\tthe switch hardware. Status and capability information cannot be\n"
	"\t\tretrieved from the hardware.",
	/* 14: GSW_MAC_TABLE_CLEAR */
	"Remove all MAC entries from the MAC table.",
	/* 15: GSW_MAC_TABLE_ENTRY_ADD */
	"Add a MAC table entry. If an entry already exists for the given MAC Address\n"
	"and Filtering Database (FID), this entry is overwritten. If not, a new entry\n"
	"is added.\n"
	"\nParameter:\n----------\n"
	"nFId :\n"
	"\tKey - Filtering Identifier (FID) (not supported by all switches)\n"
	"\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"nAgeTimer :\n"
	"\tAging Time, given in multiples of 1 second in a range from 1 s to\n"
	"\t1,000,000 s. The configured value might be rounded that it fits to the\n"
	"\tgiven hardware platform.\n"
	"\n"
	/* "nSVLAN_Id :\n"
	 "\tSTAG VLAN Id. Only applicable in case SVLAN support is enabled on the device.\n"
	 "\n"*/
	"nSubIfId :\n"
	"\tSub-Interface Identifier Destination (supported in GSWIP-3.0 only)..\n"
	"\n"
	"bStaticEntry :\n"
	"\tStatic Entry (value will be aged out if the entry is not set to\n"
	"\tstatic). The switch API implementation uses the maximum age timer in\n"
	"\tcase the entry is not static.\n"
	"\n"
	"nTrafficClass :\n"
	"\tEgress queue traffic class. The queue index starts counting from zero.\n"
	"\n"
	"nMAC :\n"
	"\tMAC Address to add to the table.\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"nFilterFlag :\n"
	"\tKey - Value 0 - not filter, 1 - source address filter\n"
	"\t2 - destination address filter, 3 - both source and destination filter.",
	/* 16: GSW_MAC_TABLE_ENTRY_QUERY */
	"Search the MAC Address table for a specific address entry. A MAC address is\n"
	"provided by the application and Switch API performs a search operation on the\n"
	"hardware table. Many hardware platforms provide an optimized and fast address\n"
	"search algorithm.\n"
	"\nParameter:\n----------\n"
	"nMAC :\n"
	"\tMAC Address. This parameter needs to be provided for the search\n"
	"\toperation. This is an input parameter.\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"nFId :\n"
	"\tKey - Get the MAC table entry belonging to the given Filtering Identifier\n"
	"\t(FID) (not supported by all switches). This is an input parameter."
	"\n"
	"nFilterFlag :\n"
	"\tKey - Value 0 - not filter, 1 - source address filter\n"
	"\t2 - destination address filter, 3 - both source and destination filter.",
	/* 17: GSW_MAC_TABLE_ENTRY_READ */
	"Read an entry of the MAC table. If the parameter 'bInitial=TRUE', the GET\n"
	"operation starts at the beginning of the table. Otherwise it continues the GET\n"
	"operation at the entry that follows the previous access. The function sets all\n"
	"fields to zero in case the end of the table is reached. In order to read out\n"
	"the complete table, this function can be called in a loop. The Switch API sets\n"
	"'bLast=1' when the last entry is read out. This 'bLast' parameter could\n"
	"be the loop exit criteria.",
	/* 18: GSW_MAC_TABLE_ENTRY_REMOVE */
	"Remove a single MAC entry from the MAC table.\n"
	"\nParameter:\n----------\n"
	"nFId :\n"
	"\tFiltering Identifier (FID) (not supported by all switches)\n"
	"\n"
	"nMAC :\n"
	"\tMAC Address to be removed from the table.\n"
	"\tSupported Formats: 12:34:45:67:89:0A",
	/* 19: GSW_MDIO_CFG_GET */
	"Read the MDIO interface configuration. The parameters can be modified using\n"
	"GSW_MDIO_CFG_SET.",
	/* 20: GSW_MDIO_CFG_SET */
	"Set the MDIO interface configuration. The parameters can be read using\n"
	"GSW_MDIO_CFG_GET. The given frequency is rounded off to fitting to the\n"
	"hardware support. GSW_MDIO_CFG_GET will return the exact programmed\n"
	"(rounded) frequency value.\n"
	"\nParameter:\n----------\n"
	"nMDIO_Speed :\n"
	"\tMDIO interface clock and data rate [in kHz].\n"
	"\n"
	"bMDIO_Enable :\n"
	"\tMDIO interface enable.",
	/* 21: GSW_MDIO_DATA_READ */
	"Read data from the MDIO Interface of the switch device. This function allows\n"
	"various kinds of information to be read out for any attached device by\n"
	"register and device addressing. The 'nData' value (GSW_MDIO_data_t)\n"
	"contains the read device register. A write operation can be done using\n"
	"GSW_MDIO_DATA_WRITE.\n"
	"\nParameter:\n----------\n"
	"nAddressDev :\n"
	"\tDevice address on the MDIO interface\n"
	"\n"
	"nAddressReg :\n"
	"\tRegister address inside the device.",
	/* 22: GSW_MDIO_DATA_WRITE */
	"Write data to the MDIO Interface of the switch device. This function allows\n"
	"for configuration of any attached device by register and device addressing.\n"
	"This applies to external and internal Ethernet PHYs as well. The 'nData' value\n"
	"(GSW_MDIO_data_t) is directly written to the device register. A read\n"
	"operation can be performed using GSW_MDIO_DATA_READ.\n"
	"\nParameter:\n----------\n"
	"nAddressDev :\n"
	"\tDevice address on the MDIO interface\n"
	"\n"
	"nAddressReg :\n"
	"\tRegister address inside the device.\n"
	"\n"
	"nData :\n"
	"\tExchange data word with the device (read / write).",
	/* 23: GSW_MMD_DATA_READ */
	"Read MMD Ethernet PHY register over the MDIO Interface attached to the switch\n"
	"device. This function allows various kinds of information to be read out for\n"
	"any attached device by register and device addressing. The 'nData' value (\ref\n"
	"GSW_MMD_data_t) contains the read MMD device register. A write operation\n"
	"can be done using \ref GSW_MMD_DATA_WRITE.\n"
	"\nParameter:\n----------\n"
	"nAddressDev :\n"
	"\tDevice address on the MDIO interface\n"
	"\n"
	"nAddressReg :\n"
	"\tMMD Register address/offset inside the device.",
	/* 24: GSW_MMD_DATA_WRITE */
	"Write MMD Ethernet PHY register over the MDIO Interface attached to the switch\n"
	"device. This function allows configuration of any attached device by MMD\n"
	"register and device addressing. This applies to external and internal Ethernet\n"
	"PHYs as well. The 'nData' value (\ref GSW_MMD_data_t) is directly\n"
	"written to the device register. A read operation can be performed using \ref\n"
	"GSW_MMD_DATA_READ.\n"
	"\nParameter:\n----------\n"
	"nAddressDev :\n"
	"\tDevice address on the MDIO interface\n"
	"\n"
	"nAddressReg :\n"
	"\tMMD Register address/offset inside the device.\n"
	"\n"
	"nData :\n"
	"\tExchange data word with the device (read / write).",
	/* 25: GSW_MONITOR_PORT_CFG_GET */
	"Reads out the current monitor options for a dedicated Ethernet port. This\n"
	"configuration can be set using GSW_MONITOR_PORT_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 26: GSW_MONITOR_PORT_CFG_SET */
	"Configures the monitor options for a dedicated Ethernet port. This current\n"
	"configuration can be read back using GSW_MONITOR_PORT_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bMonitorPort :\n"
	"\tThis port is used as a monitor port. To use this feature, the port\n"
	"\tmirror function is enabled on one or more ports.",
	/* 27: GSW_MULTICAST_ROUTER_PORT_ADD */
	"Add static router port to the switch hardware multicast table. These added\n"
	"router ports will not be removed by the router port learning aging process.\n"
	"The router port learning is enabled over the parameter 'bLearningRouter' over\n"
	"the GSW_MULTICAST_SNOOP_CFG_GET command. Router port learning and static\n"
	"added entries can both be used together. In case of a sofware IGMP\n"
	"stack/daemon environemtn, the router port learning does not have to be\n"
	"configured on the switch hardware. Instead the router port management is\n"
	"handled by the IGMP stack/daemon. A port can be removed using\n"
	"GSW_MULTICAST_ROUTER_PORT_REMOVE.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 28: GSW_MULTICAST_ROUTER_PORT_READ */
	"Check if a port has been selected as a router port, either by automatic\n"
	"learning or by manual setting. A port can be added using\n"
	"GSW_MULTICAST_ROUTER_PORT_ADD. A port can be removed again using\n"
	"GSW_MULTICAST_ROUTER_PORT_REMOVE.\n"
	"\nParameter:\n----------\n"
	"bInitial :\n"
	"\tRestart the get operation from the start of the table. Otherwise\n"
	"\treturn the next table entry (next to the entry that was returned\n"
	"\tduring the previous get operation). This parameter is always reset\n"
	"\tduring the read operation. This boolean parameter is set by the\n"
	"\tcalling application.\n"
	"\n"
	"bLast :\n"
	"\tIndicates that the read operation got all last valid entries of the\n"
	"\ttable. This boolean parameter is set by the switch API when the Switch\n"
	"\tAPI is called after the last valid one was returned already.\n"
	"\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 29: GSW_MULTICAST_ROUTER_PORT_REMOVE */
	"Remove an Ethernet router port from the switch hardware multicast table. A\n"
	"port can be added using GSW_MULTICAST_ROUTER_PORT_ADD.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 30: GSW_MULTICAST_SNOOP_CFG_GET */
	"Read out the current switch multicast configuration. The configuration can be\n"
	"set using GSW_MULTICAST_SNOOP_CFG_SET.",
	/* 31: GSW_MULTICAST_SNOOP_CFG_SET */
	"Configure the switch multicast configuration. The currently used configuration\n"
	"can be read using GSW_MULTICAST_SNOOP_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"eIGMP_Mode :\n"
	"\tEnables and configures the IGMP/MLD snooping feature. Select\n"
	"\tautolearning or management packet forwarding mode. Packet forwarding\n"
	"\tis done to the port selected in 'eForwardPort'.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: IGMP management packet snooping and multicast level 3 table\n"
	"\t\tlearning is disabled.\n"
	"\n"
	"\t1: IGMP management packet snooping is enabled and used for the\n"
	"\t\thardware auto-learning to fill the multicast level 3 table.\n"
	"\n"
	"\t2: IGMP management packet snooping is enabled and forwarded to the\n"
	"\t\tconfigured port. No autolearning of the multicast level 3 table.\n"
	"\t\tThis table has to be maintained by the management software.\n"
	"\n"
	"bIGMPv3 :\n"
	"\tIGMPv3 hardware support. When enabled the IGMP table includes both the\n"
	"\tgroup table and the source list table. Otherwise the table only\n"
	"\tincludes the group table. This feature is needed when supporting\n"
	"\tIGMPv3 and MLDv2 protocols.\n"
	"\n"
	"bCrossVLAN :\n"
	"\tEnables snooped IGMP control packets treated as cross-VLAN packets.\n"
	"\tThis parameter is used for hardware auto-learning and snooping packets\n"
	"\tforwarded to a dedicated port. This dedicated port can be selected\n"
	"\tover 'eForwardPort'.\n"
	"\n"
	"eForwardPort :\n"
	"\tForward snooped packet, only used if forwarded mode is selected by\n"
	"\t'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Default; portmap is determined by the forwarding classification.\n"
	"\n"
	"\t1: Discard; discard packets.\n"
	"\n"
	"\t2: Forward to the CPU port. This requires that the CPU port is\n"
	"\t\tpreviously set by calling GSW_CPU_PORT_CFG_SET.\n"
	"\n"
	"\t3: Forward to a port, selected by the parameter 'nForwardPortId'.\n"
	"\t\tPlease note that this feature is not supported by all hardware\n"
	"\t\tplatforms.\n"
	"\n"
	"nForwardPortId :\n"
	"\tTarget port for forwarded packets, only used if selected by\n"
	"\t'eForwardPort'. Forwarding is done if 'eForwardPort =\n"
	"\tGSW_PORT_FORWARD_PORT'.\n"
	"\n"
	"nClassOfService :\n"
	"\tSnooping control class of service. Snooping control packet can be\n"
	"\tforwarded to the 'nForwardPortId' when selected in 'eIGMP_Mode'. The\n"
	"\tclass of service of this port can be selected for the snooped control\n"
	"\tpackets, starting from zero. The maximum possible service class\n"
	"\tdepends on the hardware platform used. The value\n"
	"\tGSW_TRAFFIC_CLASS_DISABLE disables overwriting the given class\n"
	"\tassignment.\n"
	"\n"
	"nRobust :\n"
	"\tRobustness variable. Used when the hardware-based IGMP/MLD snooping\n"
	"\tfunction is enabled. This robust variable is used in case IGMP\n"
	"\thardware learning is enabled ('eIGMP_Mode =\n"
	"\tGSW_MULTICAST_SNOOP_MODE_AUTOLEARNING'). Supported range: 1 ...\n"
	"\t3\n"
	"\n"
	"nQueryInterval :\n"
	"\tQuery interval. Used to define the query interval in units of 100 ms\n"
	"\twhen the hardware-based IGMP/MLD snooping function is enabled. The\n"
	"\tautomatically learned router port will be aged out if no IGMP/MLD\n"
	"\tquery frame is received from the router port for (nQueryInterval *\n"
	"\tnRobust) seconds. The supported range is from 100 ms to 25.5 s, with a\n"
	"\tdefault value of 10 s. This query interval is used in case IGMP\n"
	"\thardware learning is enabled ('eIGMP_Mode =\n"
	"\tGSW_MULTICAST_SNOOP_MODE_AUTOLEARNING').\n"
	"\n"
	"eSuppressionAggregation :\n"
	"\tIGMP/MLD report suppression and Join Aggregation control. Whenever the\n"
	"\treport message is already sent out for the same multicast group, the\n"
	"\tsuccessive report message within the query-max-responsetime with the\n"
	"\tsame group ID will be filtered by the switch. This is called report\n"
	"\tsuppression. Whenever the join message is already sent out for the\n"
	"\tsame multicast group, the successive join message with the same group\n"
	"\tID will be filtered. This is called join aggregation. This suppression\n"
	"\tcontrol is used in case IGMP hardware learning is enable ('eIGMP_Mode\n"
	"\t= GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING').\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Report Suppression and Join Aggregation.\n"
	"\n"
	"\t1: Report Suppression. No Join Aggregation.\n"
	"\n"
	"\t2: Transparent Mode. No Report Suppression and no Join Aggregation.\n"
	"\n"
	"bFastLeave :\n"
	"\tHardware IGMP snooping fast leave option. Allows the hardware to\n"
	"\tautomatically clear the membership when receiving the IGMP leave\n"
	"\tpacket. This fast leave option is used in case IGMP hardware learning\n"
	"\tis enabled ('eIGMP_Mode =\n"
	"\tGSW_MULTICAST_SNOOP_MODE_AUTOLEARNING'). Note: The fast-leave\n"
	"\toption shall only be enabled where only one host is connected to each\n"
	"\tinterface. If fast-leave is enabled where more than one host is\n"
	"\tconnected to an interface, some hosts might be dropped inadvertently.\n"
	"\tFast-leave processing is supported only with IGMP version 2 hosts.\n"
	"\n"
	"bLearningRouter :\n"
	"\tHardware router port auto-learning. Allows for the ports on which a\n"
	"\trouter is located to be learned automatically. This router port\n"
	"\tlearning option is used in case IGMP hardware learning is enabled\n"
	"\t('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING').\n"
	"bMulticastUnknownDrop :\n"
	"\tDiscard Unknown IP Multicast Packets. Multicast packets are defined as\n"
	"\tunknown in case the group address cannot be found in the switch multicast\n"
	"\tgroup table. The table group entries could be either automatically learned or\n"
	"\tthey are statically added. This Boolean parameter defines if such unknown\n"
	"\tmulticast packet are forwarded to the multicast forwarding portmap  \n"
	"\t(command \ref GSW_PORT_CFG_SET, parameter 'bMulticastUnknownDrop') or \n"
	"\tif they are dropped instead.\n"
	"\t0: Forward unknown multicast packets for the multicast forwarding portmap.\n"
	"\t1: Drop unknown multicast packets. \n"
	"bMulticastFIDmode :\n"
	"\tMulticast Forwarding based upon FID or Not - valid for GSWIP-3.0 only \n"
	"\t0: Multicast Forwarding is not based upon FID.\n"
	"\t1: Multicast Forwarding is based upon FID. \n"
	"\n",
	/* 32: GSW_MULTICAST_TABLE_ENTRY_ADD */
	"Adds a multicast group configuration to the multicast table. No new entry is\n"
	"added in case this multicast group already exists in the table. This commands\n"
	"adds a host member to the multicast group. A member can be removed again using\n"
	"GSW_MULTICAST_TABLE_ENTRY_REMOVE.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"nSubIfId :\n"
	"\tSub-Interface Id - valid for GSWIP 3.0 only\n"
	"\n"
	"nFID :\n"
	"\tFID - valid for GSWIP 3.0 only subject to Global FID for MC is enabled\n"
	"\n"
	"eIPVersion :\n"
	"\tSelect the IP version of the 'uIP_Gda' and 'uIP_Gsa' fields. Both\n"
	"\tfields support either IPv4 or IPv6.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: IPv4\n"
	"\n"
	"\t1: IPv6\n"
	"\n"
	"uIP_Gda :\n"
	"\tGroup Destination IP address (GDA).\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"uIP_Gsa :\n"
	"\tGroup Source IP address. Only used in case IGMPv3 support is enabled\n"
	"\tand 'eModeMember != GSW_IGMP_MEMBER_DONT_CARE'.\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"eModeMember :\n"
	"\tGroup member filter mode. This parameter is ignored when deleting a\n"
	"\tmulticast membership table entry. The configurations\n"
	"\t'GSW_IGMP_MEMBER_EXCLUDE' and 'GSW_IGMP_MEMBER_INCLUDE'\n"
	"\tare only supported if IGMPv3 is used.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Include source IP address membership mode. Only supported for\n"
	"\t\tIGMPv3.\n"
	"\n"
	"\t1: Exclude source IP address membership mode. Only supported for\n"
	"\t\tIGMPv3.\n"
	"\n"
	"\t2: Group source IP address is 'don't care'. This means all source IP\n"
	"\t\taddresses (*) are included for the multicast group membership. This\n"
	"\t\tis the default mode for IGMPv1 and IGMPv2.\n"
	"bExclSrcIP :\n"
	"\tExclude Mode - valid for GSWIP 3.0 only - Includes or Excludes Source IP - uIP_Gsa\n"
	"\n",
	/* 33: GSW_MULTICAST_TABLE_ENTRY_READ */
	"Read out the multicast membership table that is located inside the switch\n"
	"hardware. The 'bInitial' parameter restarts the read operation at the\n"
	"beginning of the table. Every following GSW_MULTICAST_TABLE_ENTRY_READ\n"
	"call reads out the next found entry. The 'bLast' parameter is set by the\n"
	"switch API in case the last entry of the table is reached.",
	/* 34: GSW_MULTICAST_TABLE_ENTRY_REMOVE */
	"Remove an host member from a multicast group. The multicast group entry is\n"
	"completely removed from the multicast table in case it has no host member port\n"
	"left. Group members can be added using GSW_MULTICAST_TABLE_ENTRY_ADD.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"nSubIfId :\n"
	"\tSub-Interface Id - valid for GSWIP 3.0 only\n"
	"\n"
	"nFID :\n"
	"\tFID - valid for GSWIP 3.0 only subject to Global FID for MC is enabled\n"
	"\n"
	"eIPVersion :\n"
	"\tSelect the IP version of the 'uIP_Gda' and 'uIP_Gsa' fields. Both\n"
	"\tfields support either IPv4 or IPv6.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: IPv4\n"
	"\n"
	"\t1: IPv6\n"
	"\n"
	"uIP_Gda :\n"
	"\tGroup Destination IP address (GDA).\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"uIP_Gsa :\n"
	"\tGroup Source IP address. Only used in case IGMPv3 support is enabled\n"
	"\tand 'eModeMember != GSW_IGMP_MEMBER_DONT_CARE'.\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"eModeMember :\n"
	"\tGroup member filter mode. This parameter is ignored when deleting a\n"
	"\tmulticast membership table entry. The configurations\n"
	"\t'GSW_IGMP_MEMBER_EXCLUDE' and 'GSW_IGMP_MEMBER_INCLUDE'\n"
	"\tare only supported if IGMPv3 is used.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Include source IP address membership mode. Only supported for\n"
	"\t\tIGMPv3.\n"
	"\n"
	"\t1: Exclude source IP address membership mode. Only supported for\n"
	"\t\tIGMPv3.\n"
	"\n"
	"\t2: Group source IP address is 'don't care'. This means all source IP\n"
	"\t\taddresses (*) are included for the multicast group membership. This\n"
	"\t\tis the default mode for IGMPv1 and IGMPv2.\n"
	"bExclSrcIP :\n"
	"\tExclude Mode - valid for GSWIP 3.0 only - Includes or Excludes Source IP - uIP_Gsa\n"
	"\n",
	/* 35: GSW_PORT_CFG_GET */
	"Read out the current Ethernet port configuration.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 36: GSW_PORT_CFG_SET */
	"Set the Ethernet port configuration.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"eEnable :\n"
	"\tEnable Port (ingress only, egress only, both directions, or disabled).\n"
	"\tThis parameter is used for Spanning Tree Protocol and 802.1X\n"
	"\tapplications.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: The port is disabled in both directions.\n"
	"\n"
	"\t1: The port is enabled in both directions (ingress and egress).\n"
	"\n"
	"\t2: The port is enabled in the receive (ingress) direction only.\n"
	"\n"
	"\t3: The port is enabled in the transmit (egress) direction only.\n"
	"\n"
	"bUnicastUnknownDrop :\n"
	"\tDrop unknown unicast packets. Do not send out unknown unicast packets\n"
	"\ton this port, if the boolean parameter is enabled. By default packets\n"
	"\tof this type are forwarded to this port.\n"
	"\n"
	"bMulticastUnknownDrop :\n"
	"\tDrop unknown multicast packets. Do not send out unknown multicast\n"
	"\tpackets on this port, if boolean parameter is enabled. By default\n"
	"\tpackets of this type are forwarded to this port.\n"
	"\n"
	"bReservedPacketDrop :\n"
	"\tDrop reserved packet types (destination address from '01 80 C2 00 00\n"
	"\t00' to '01 80 C2 00 00 2F') received on this port.\n"
	"\n"
	"bBroadcastDrop :\n"
	"\tDrop Broadcast packets received on this port. By default packets of\n"
	"\tthis type are forwarded to this port.\n"
	"\n"
	"bAging :\n"
	"\tEnables MAC address table aging. The MAC table entries learned on this\n"
	"\tport are removed after the aging time has expired. The aging time is a\n"
	"\tglobal parameter, common to all ports.\n"
	"\n"
	"bLearning :\n"
	"\tMAC address table learning on the port specified by 'nPortId'.\n"
	"\tBy default this parameter is always enabled. \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Learning is enabled. \n"
	"\t1: Learning is disabled.\n"
	"\n"
	"bLearningMAC_PortLock :\n"
	"\tAutomatic MAC address table learning locking on the port specified by\n"
	"\t'nPortId'.\n"
	"\n"
	"nLearningLimit :\n"
	"\tAutomatic MAC address table learning limitation on this port. The\n"
	"\tlearning functionality is disabled when the limit value is zero. The\n"
	"\tvalue 0xFFFF to allow unlimited learned address.\n"
	"\n"
	"bMAC_SpoofingDetection :\n"
	"\tMAC spoofing detection. Identifies ingress packets that carry a MAC source address\n"
	"\twhich was previously learned on a different ingress port (learned by MAC bridging table).\n"
	"\tThis also applies to static added entries. Those violated packets could be\n"
	"\taccepted or discarded, depending on the global switch configuration 'bMAC_SpoofingAction'.\n"
	"\tThis parameter is only taken into account when 'bLearning' is enabled.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Port MAC address spoofing detection is not enabled. \n"
	"\t1: Port MAC address spoofing detection is enabled.\n"
	"\n"
	"eFlowCtrl :\n"
	"\tPort Flow Control Status. Enables the flow control function.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Automatic flow control mode selection through auto-negotiation.\n"
	"\n"
	"\t1: Receive flow control only\n"
	"\n"
	"\t2: Transmit flow control only\n"
	"\n"
	"\t3: Receive and Transmit flow control\n"
	"\n"
	"\t4: No flow control\n"
	"\n"
	"ePortMonitor :\n"
	"\tPort monitor feature. Allows forwarding of egress and/or ingress\n"
	"\tpackets to the monitor port. If enabled, the monitor port gets a copy\n"
	"\tof the selected packet type.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Mirror Feature is disabled. Normal port usage.\n"
	"\n"
	"\t1: Port Ingress packets are mirrored to the monitor port.\n"
	"\n"
	"\t2: Port Egress packets are mirrored to the monitor port.\n"
	"\n"
	"\t3: Port Ingress and Egress packets are mirrored to the monitor port.\n"
	"\n"
	"\t4: Packet mirroring of 'unknown VLAN violation' frames.\n"
	"\n"
	"\t16: Packet mirroring of 'VLAN ingress or egress membership violation'\n"
	"\t\tframes.\n"
	"\n"
	"\t32: Packet mirroring of 'port state violation' frames.\n"
	"\n"
	"\t64: Packet mirroring of 'MAC learning limit violation' frames.\n"
	"\n"
	"\t128: Packet mirroring of 'port lock violation' frames.\n"
	"bIfCounters :\n"
	"\tAssign Interface RMON Counters for this Port - GSWIP-3.0\n"
	"nIfCountStartIdx :\n"
	"\tInterface RMON Counters Start Index - GSWIP-3.0. \n"
	"\tValue of (-1) denotes unassigned Interface Counters.\n"
	"\tValid range : 0-255 available to be shared amongst ports in desired way.\n"
	"eIfRMONmode :\n"
	"\tInterface RMON Counters Mode - GSWIP-3.0\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: FID based Interface RMON counters Usage.\n"
	"\n"
	"\t1: Sub-Interface Id based Interface RMON counters Usage .\n"
	"\n"
	"\t2: Flow Id (LSB bits 3 to 0) based Interface RMON counters Usage .\n"
	"\n"
	"\t3: Flow Id (MSB bits 7 to 4) based Interface RMON counters Usage.\n"
	"\n",
	/* 37: GSW_PORT_LINK_CFG_GET */
	"Read out the Ethernet port's speed, link status, and flow control status. The\n"
	"information for one single port 'nPortId' is returned. An error code is\n"
	"returned if the selected port does not exist.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 38: GSW_PORT_LINK_CFG_SET */
	"Set the Ethernet port link, speed status and flow control status. The\n"
	"configuration applies to a single port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bDuplexForce :\n"
	"\tForce Port Duplex Mode. - 0: Negotiate Duplex Mode.\n"
	"\tAuto-negotiation mode. Negotiated duplex mode given in 'eDuplex'\n"
	"\tduring GSW_PORT_LINK_CFG_GET calls. - 1: Force Duplex\n"
	"\tMode. Force duplex mode in 'eDuplex'.\n"
	"\n"
	"eDuplex :\n"
	"\tPort Duplex Status.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Port operates in full-duplex mode\n"
	"\n"
	"\t1: Port operates in half-duplex mode\n"
	"\n"
	"bSpeedForce :\n"
	"\tForce Link Speed. - 0: Negotiate Link Speed. Negotiated speed\n"
	"\tgiven in 'eSpeed' during GSW_PORT_LINK_CFG_GET calls. -\n"
	"\t1: Force Link Speed. Forced speed mode in 'eSpeed'.\n"
	"\n"
	"eSpeed :\n"
	"\tEthernet port link up/down and speed status.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t10: 10 Mbit/s\n"
	"\n"
	"\t100: 100 Mbit/s\n"
	"\n"
	"\t200: 200 Mbit/s\n"
	"\n"
	"\t1000: 1000 Mbit/s\n"
	"\n"
	"bLinkForce :\n"
	"\tForce Link. - 0: Auto-negotiate Link. Current link status is\n"
	"\tgiven in 'eLink' during GSW_PORT_LINK_CFG_GET calls. - 1:\n"
	"\tForce Duplex Mode. Force duplex mode in 'eLink'.\n"
	"\n"
	"eLink :\n"
	"\tLink Status. Read out the current link status. Note that the link\n"
	"\tcould be forced by setting 'bLinkForce'.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Link up. Any connected LED still behaves based on the real PHY\n"
	"\t\tstatus.\n"
	"\n"
	"\t1: Link down.\n"
	"\n"
	"eMII_Mode :\n"
	"\tSelected interface mode (MII/RMII/RGMII/GMII).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Normal PHY interface (twisted pair), use the internal MII\n"
	"\t\tInterface.\n"
	"\n"
	"\t1: Reduced MII interface in normal mode.\n"
	"\n"
	"\t2: GMII or MII, depending upon the speed.\n"
	"\n"
	"\t3: RGMII mode.\n"
	"\n"
	"eMII_Type :\n"
	"\tSelect MAC or PHY mode (PHY = Reverse xMII).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: MAC Mode. The Ethernet port is configured to work in MAC mode.\n"
	"\n"
	"\t1: PHY Mode. The Ethernet port is configured to work in PHY mode.\n"
	"\n"
	"eClkMode :\n"
	"\tInterface Clock mode (used for RMII mode).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Clock Mode not applicable.\n"
	"\n"
	"\t1: Clock Master Mode. The port is configured to provide the clock as\n"
	"\t\toutput signal.\n"
	"\n"
	"\t2: Clock Slave Mode. The port is configured to use the input clock\n"
	"\t\tsignal.\n"
	"\n"
	"bLPI :\n"
	"\t'Low Power Idle' Support for 'Energy Efficient Ethernet'. Only enable\n"
	"\tthis feature in case the attached PHY also supports it.",
	/* 39: GSW_PORT_PHY_ADDR_GET */
	"Read out the MDIO device address of an Ethernet PHY that is connected to an\n"
	"Ethernet port. This device address is useful when accessing PHY registers\n"
	"using the commands GSW_MDIO_DATA_WRITE, GSW_MDIO_DATA_READ,\n"
	"GSW_MMD_DATA_WRITE and GSW_MMD_DATA_READ.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 40: GSW_PORT_PHY_QUERY */
	"Check whether the Ethernet switch hardware has detected an Ethernet PHY\n"
	"connected to the given Ethernet port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 41: GSW_PORT_REDIRECT_GET */
	"Ingress and egress packets of one specific Ethernet port can be redirected to\n"
	"the CPU port. The ingress and egress packet redirection can be configured\n"
	"individually. This command reads out the current configuration of a dedicated\n"
	"port. A new configuration can be applied by calling\n"
	"GSW_PORT_REDIRECT_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 42: GSW_PORT_REDIRECT_SET */
	"Select ingress and egress packets of one specific Ethernet port that can be\n"
	"redirected to a port that is configured as the 'CPU port'. The ingress and\n"
	"egress packet direction can be configured individually. The packet filter of\n"
	"the original port still applies to the packet (for example, MAC address\n"
	"learning is done for the selected port and not for the CPU port). On CPU port\n"
	"side, no additional learning, forwarding look up, VLAN processing and queue\n"
	"selection is performed for redirected packets. Depending on the hardware\n"
	"platform used, the CPU port has to be set in advance using\n"
	"GSW_CPU_PORT_CFG_SET. The currently used configuration can be read using\n"
	"GSW_PORT_REDIRECT_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bRedirectEgress :\n"
	"\tPort Redirect Option. If enabled, all packets destined to 'nPortId'\n"
	"\tare redirected to the CPU port. The destination port map in the status\n"
	"\theader information is not changed so that the original destination\n"
	"\tport can be identified by software.\n"
	"\n"
	"bRedirectIngress :\n"
	"\tPort Ingress Direct Forwarding. If enabled, all packets sourced from\n"
	"\t'nPortId' are directly forwarded to queue 0 of the CPU port. These\n"
	"\tpackets are not modified and are not affected by normal learning, look\n"
	"\tup, VLAN processing and queue selection.",
	/* 43: GSW_PORT_RGMII_CLK_CFG_GET */
	"Read the RGMII clocking parameter in case the Ethernet port is configured in\n"
	"RGMII mode. The configuration can be set by calling\n"
	"GSW_PORT_RGMII_CLK_CFG_SET. It applies to a single port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 44: GSW_PORT_RGMII_CLK_CFG_SET */
	"Configure the RGMII clocking parameter in case the Ethernet port is configured\n"
	"in RGMII mode. The configuration can be read by calling\n"
	"GSW_PORT_RGMII_CLK_CFG_GET. It applies to a single port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"nDelayRx :\n"
	"\tClock Delay RX [multiple of 500 ps].\n"
	"\n"
	"nDelayTx :\n"
	"\tClock Delay TX [multiple of 500 ps].",
	/* 45: GSW_QOS_CLASS_DSCP_GET */
	"Read out the current traffic class to DSCP mapping table. The table can be\n"
	"written using GSW_QOS_CLASS_DSCP_SET.",
	/* 46: GSW_QOS_CLASS_DSCP_SET */
	"Configure the traffic class to DSCP priority mapping table. This table is\n"
	"global for the whole switch device. The table can be read by\n"
	"GSW_QOS_CLASS_DSCP_GET.\n"
	"\nParameter:\n----------\n"
	"nTrafficClass\n"
	"\t\tTable index of the traffic table to DSCP (6-bit) mapping\n"
	"\t\ttable. The index starts counting from zero.\n"
	"nDSCP :\n"
	"\t\tDSCP value (6-bit) associated with a particular Traffic class.",
	/* 47: GSW_QOS_CLASS_PCP_GET */
	"Read out the current traffic class to 802.1P (PCP) priority mapping table.\n"
	"This table is global and valid for the entire switch device. The table can be\n"
	"written using GSW_QOS_CLASS_PCP_SET.",
	/* 48: GSW_QOS_CLASS_PCP_SET */
	"Configure the traffic class to 802.1P (PCP) priority mapping table. This table\n"
	"is global for the whole switch device. The table can be read by\n"
	"GSW_QOS_CLASS_PCP_GET.\n"
	"\nParameter:\n----------\n"
	"nTrafficClass :\n"
	"\t\tTable index of the traffic table to PCP (3-bit) mapping\n"
	"\t\ttable. The index starts counting from zero.\n"
	"nPCP :\n"
	"\t\tPCP (3-bit) value associated with a particular traffic class.",
	/* 49: GSW_QOS_DSCP_CLASS_GET */
	"Read out the QoS 64 DSCP mapping to the switch priority queues. The table\n"
	"configuration can be set using GSW_QOS_DSCP_CLASS_SET.",
	/* 50: GSW_QOS_DSCP_CLASS_SET */
	"Initialize the QoS 64 DSCP priority mapping to the switch priority queues.\n"
	"This configuration applies for the whole switch device. The table\n"
	"configuration can be read by GSW_QOS_DSCP_CLASS_GET.\n"
	"\nParameter:\n----------\n"
	"nDSCP :\n"
	"\t\tTable index of the DSCP to traffic table mapping\n"
	"\t\ttable. The index starts counting from zero.\n"
	"nTrafficClass :\n"
	"\t\tTraffic class associated with a particular DSCP\n"
	"\t\tvalue.",
	/* 51: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET */
	"Read out the current DSCP to Drop Precedence assignment mapping table. The\n"
	"table can be configured using GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET.",
	/* 52: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET */
	"Configures the DSCP to Drop Presedence assignment mapping table. This mapping\n"
	"table is used to identify the switch internal used drop precedence based on\n"
	"the DSCP value of the incoming packet. The current mapping table configuration\n"
	"can be read by GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nDSCP :\n"
	"\t\tTable index of the DSCP to Drop Presedence assignment\n"
	"\t\ttable. The index starts counting from zero.\n"
	"nDSCP_DropPrecedence :\n"
	"\t\tDSCP to drop presedence assignment. Every array entry\n"
	"\t\trepresent the drop presedence for one of the 64\n"
	"\t\texisting DSCP values. DSCP is the index to an array\n"
	"\t\tof resulting drop presedence values. The index starts\n"
	"\t\tcounting from zero.\n"
	"\t\tSupported Values:\n"
	"\t\t-----------------\n"
	"\t\t0: Critical Packet. Metering will never changes their\n"
	"\t\tdrop precedence of these packets.\n\n"
	"\t\t1: Green Drop Precedence Packet. Packet is marked\n"
	"\t\twith a 'low' drop precedence.\n\n"
	"\t\t2: Yellow Drop Precedence Packet. Packet is marked\n"
	"\t\twith a 'middle' drop precedence.\n\n"
	"\t\t3: Red Drop Precedence Packet. Packet is marked with\n"
	"\t\ta 'high' drop precedence.",
	/* 53: GSW_QOS_METER_CFG_GET */
	"Configure the parameters of a rate meter instance. This instance can be\n"
	"assigned to an ingress/egress port using GSW_QOS_METER_PORT_ASSIGN. It\n"
	"can also be used by the flow classification engine. The total number of\n"
	"available rate meters can be retrieved by the capability list using\n"
	"GSW_CAP_GET. The current configuration of a meter instance can be\n"
	"retrieved using GSW_QOS_METER_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter index (zero-based counting).",
	/* 54: GSW_QOS_METER_CFG_SET */
	"This command configures the parameters of a rate meter instance. This instance\n"
	"can be assigned to an ingress/egress port by using\n"
	"GSW_QOS_METER_PORT_ASSIGN. It can also be used by the flow\n"
	"classification engine. The total number of available rate meters can be\n"
	"retrieved by the capability list using GSW_CAP_GET. The current\n"
	"configuration of a meter instance can be retrieved using\n"
	"GSW_QOS_METER_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"bEnable :\n"
	"\tEnable/Disable the meter shaper.\n"
	"\n"
	"nMeterId :\n"
	"\tMeter index (zero-based counting).\n"
	"\n"
	"nCbs :\n"
	"\tCommitted Burst Size (CBS [Bytes]).\n"
	"\n"
	"nEbs :\n"
	"\tExcess Burst Size (EBS [Bytes]).\n"
	"\n"
	"nRate :\n"
	"\tCommitted Information Rate (CIR [kbit/s])\n"
	"nPiRate :\n"
	"\tPeak Information Rate (PIR [kbit/s]) - applicable for trTCM only)"
	"\n",
	/* 55: GSW_QOS_METER_PORT_ASSIGN */
	"Assign a rate meter instance to an ingress and/or egress port. A maximum of\n"
	"two meter IDs can be assigned to one single ingress port. This meter instance\n"
	"to port assignment can be removed using GSW_QOS_METER_PORT_DEASSIGN. A\n"
	"list of all available assignments can be read using\n"
	"GSW_QOS_METER_PORT_GET.\n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter index (zero-based counting).\n"
	"\n"
	"eDir :\n"
	"\tPort assignment. Could be either ingress, egress or both. Setting it\n"
	"\tto 'GSW_DIRECTION_NONE' would remove the queue for any port\n"
	"\tassignment.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No direction.\n"
	"\n"
	"\t1: Ingress direction.\n"
	"\n"
	"\t2: Egress direction.\n"
	"\n"
	"\t3: Ingress and egress direction.\n"
	"\n"
	"nPortIngressId :\n"
	"\tIngress Port Id.\n"
	"\n"
	"nPortEgressId :\n"
	"\tEgress Port Id.",
	/* 56: GSW_QOS_METER_PORT_DEASSIGN */
	"Deassign a rate meter instance from an ingress and/or egress port. A maximum\n"
	"of two meter IDs can be assigned to one single ingress port. The meter\n"
	"instance is given to the command and the port configuration is returned. An\n"
	"instance to port assignment can be done using GSW_QOS_METER_PORT_ASSIGN.\n"
	"A list of all available assignments can be read using\n"
	"GSW_QOS_METER_PORT_GET.\n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter index (zero-based counting).\n"
	"\n"
	"eDir :\n"
	"\tPort assignment. Could be either ingress, egress or both. Setting it\n"
	"\tto 'GSW_DIRECTION_NONE' would remove the queue for any port\n"
	"\tassignment.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No direction.\n"
	"\n"
	"\t1: Ingress direction.\n"
	"\n"
	"\t2: Egress direction.\n"
	"\n"
	"\t3: Ingress and egress direction.\n"
	"\n"
	"nPortIngressId :\n"
	"\tIngress Port Id.\n"
	"\n"
	"nPortEgressId :\n"
	"\tEgress Port Id.",
	/* 57: GSW_QOS_METER_PORT_GET */
	"Reads out all meter instance to port assignments that are done using\n"
	"GSW_QOS_METER_PORT_ASSIGN. All assignments are read from an internal\n"
	"table where every read call retrieves the next entry of the table. Setting the\n"
	"parameter 'bInitial' starts the read operation at the beginning of the table.\n"
	"The returned parameter 'bLast' indicates that the last element of the table\n"
	"was returned.",
	/* 58: GSW_QOS_PCP_CLASS_GET */
	"Read out the PCP to traffic class mapping table. The table configuration can\n"
	"be set using GSW_QOS_PCP_CLASS_SET.",
	/* 59: GSW_QOS_PCP_CLASS_SET */
	"Initialize the QoS 802.1P switch priority queue mapping. This configuration\n"
	"applies for the whole switch device. The table configuration can be read by\n"
	"GSW_QOS_PCP_CLASS_GET.\n"
	"\nParameter:\n----------\n"
	"nPCP :\n"
	"\t\tTable index of the PCP to traffic table mapping\n"
	"\t\ttable. The index starts counting from zero.\n"
	"nTrafficClass :\n"
	"\t\tTraffic class associated with a particular PCP value.",
	/* 60: GSW_QOS_PORT_CFG_GET */
	"Read out the current Ethernet port traffic class of ingress packets. It is\n"
	"used to identify the packet priority and the related egress priority queue.\n"
	"The port configuration can be set using GSW_QOS_PORT_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 61: GSW_QOS_PORT_CFG_SET */
	"Configures the Ethernet port based traffic class assignment of ingress\n"
	"packets. It is used to identify the packet priority and the related egress\n"
	"priority queue. For DSCP, the priority to queue assignment is done using\n"
	"GSW_QOS_DSCP_CLASS_SET. For VLAN, the priority to queue assignment is\n"
	"done using GSW_QOS_PCP_CLASS_SET. The current port configuration can be\n"
	"read using GSW_QOS_PORT_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"eClassMode :\n"
	"\tSelect the packet header field on which to base the traffic class\n"
	"\tassignment.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No traffic class assignment based on DSCP or PCP\n"
	"\n"
	"\t1: Traffic class assignment based on DSCP. PCP information is ignored.\n"
	"\t\tThe Port Class is used in case DSCP is not available in the packet.\n"
	"\n"
	"\t2: Traffic class assignment based on PCP. DSCP information is ignored.\n"
	"\t\tThe Port Class is used in case PCP is not available in the packet.\n"
	"\n"
	"\t3: Traffic class assignment based on DSCP. Make the assignment based\n"
	"\t\ton PCP in case the DSCP information is not available in the packet\n"
	"\t\theader. The Port Class is used in case both are not available in\n"
	"\t\tthe packet.\n"
	"\n"
	"\t4: CTAG VLAN PCP, IP DSCP. Traffic class assignment based\n"
	"\t\t on CTAG VLAN PCP, alternative use DSCP based assignment.\n"
	"\n"
	"\t5: STAG VLAN PCP. Traffic class assignment based on STAG VLAN PCP. \n"
	"\n"
	"\t6: STAG VLAN PCP, IP DSCP. Traffic class assignment based\n"
	"\t\t on STAG VLAN PCP, alternative use DSCP based assignment.\n"
	"\n"
	"\t7: IP DSCP, STAG VLAN PCP. Traffic class assignment based\n"
	"\t\ton DSCP, alternative use STAG VLAN PCP based assignment.\n"
	"\n"
	"\t8: STAG VLAN PCP, CTAG VLAN PCP. Traffic class assignment based\n"
	"\t\ton STAG VLAN PCP, alternative use CTAG VLAN PCP based assignment.\n"
	"\n"
	"\t9: STAG VLAN PCP, CTAG VLAN PCP, IP DSCP. Traffic class assignment\n"
	"\t\tbased on STAG VLAN PCP, alternative use CTAG VLAN PCP based \n"
	"\t\tassignment, alternative use DSCP based assignment. \n"
	"\n"
	"\t10: IP DSCP, STAG VLAN PCP, CTAG VLAN PCP. Traffic class assignment\n"
	"\t\t based on DSCP, alternative use STAG VLAN PCP based\n"
	"\t\t assignment, alternative use CTAG VLAN PCP based assignment.\n"
	"\n"
	"nTrafficClass :\n"
	"\tDefault port priority in case no other priority (such as VLAN-based\n"
	"\tPCP or IP-based DSCP) is used.",
	/* 62: GSW_QOS_PORT_REMARKING_CFG_GET */
	"Read out the Port Remarking Configuration. Ingress and Egress remarking\n"
	"options for DSCP and PCP. Remarking is done either on the used traffic class\n"
	"or the drop precedence. The current configuration can be set using\n"
	"GSW_QOS_PORT_REMARKING_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 63: GSW_QOS_PORT_REMARKING_CFG_SET */
	"Port Remarking Configuration. Ingress and Egress remarking options for DSCP\n"
	"and PCP. Remarking is done either on the used traffic class or the drop\n"
	"precedence. The current configuration can be read using\n"
	"GSW_QOS_PORT_REMARKING_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"eDSCP_IngressRemarkingEnable :\n"
	"\tIngress DSCP Remarking. Specifies on ingress side how a packet should\n"
	"\tbe remarked. This DSCP remarking only works in case remarking is\n"
	"\tenabled on the egress port. This configuration requires that remarking\n"
	"\tis also enabled on the egress port. DSCP remarking enable on either\n"
	"\tingress or egress port side does not perform any remark operation.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No DSCP Remarking. No remarking is done on the egress port.\n"
	"\n"
	"\t1: TC DSCP 6-Bit Remarking. The complete DSCP remarking is done based\n"
	"\t\ton the traffic class. The traffic class to DSCP value mapping is\n"
	"\t\tgiven in a device global table.\n"
	"\n"
	"\t2: TC DSCP 3-Bit Remarking. The upper 3-Bits of the DSCP field are\n"
	"\t\tremarked based on the traffic class. The traffic class to DSCP\n"
	"\t\tvalue mapping is given in a device global table.\n"
	"\n"
	"\t3: Drop Precedence Remarking. The Drop Precedence is remarked on the\n"
	"\t\tegress side.\n"
	"\n"
	"\t4: TC Drop Precedence Remarking. The Drop Precedence is remarked on\n"
	"\t\tthe egress side and the upper 3-Bits of the DSCP field are remarked\n"
	"\t\tbased on the traffic class. The traffic class to DSCP value mapping\n"
	"\t\tis given in a device global table.\n"
	"\n"
	"bDSCP_EgressRemarkingEnable :\n"
	"\tEgress DSCP Remarking. Applies remarking on egress packets in a\n"
	"\tfashion as specified on the ingress port. This ingress port remarking\n"
	"\tis configured by the parameter 'eDSCP_IngressRemarking'. This\n"
	"\tconfiguration requires that remarking is also enabled on the ingress\n"
	"\tport. DSCP remarking enable on either ingress or egress port side does\n"
	"\tnot perform any remark operation.\n"
	"\n"
	"bPCP_IngressRemarkingEnable :\n"
	"\tIngress PCP Remarking. Applies remarking to all port ingress packets.\n"
	"\tThis configuration requires that remarking is also enabled on the\n"
	"\tegress port. PCP remarking enable on either ingress or egress port\n"
	"\tside does not perform any remark operation.\n"
	"\n"
	"bPCP_EgressRemarkingEnable :\n"
	"\tEgress PCP Remarking. Applies remarking for all port egress packets.\n"
	"\tThis configuration requires that remarking is also enabled on the\n"
	"\tingress port. PCP remarking enable on either ingress or egress port\n"
	"\tside does not perform any remark operation."
	"bSTAG_PCP_IngressRemarkingEnable :\n"
	"\tIngress STAG VLAN PCP Remarking.\n"
	"bSTAG_DEI_IngressRemarkingEnable :\n"
	"\tIngress STAG VLAN DEI Remarking.\n"
	"bSTAG_PCP_DEI_EgressRemarkingEnable :\n"
	"\tEgress STAG VLAN PCP & DEI Remarking.\n"
	"\n",
	/* 64: GSW_QOS_QUEUE_PORT_GET */
	"Read out the traffic class and port assignment done using\n"
	"GSW_QOS_QUEUE_PORT_SET. Please note that the device comes along with a\n"
	"default configuration and assignment.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. This is an input parameter for\n"
	"\tGSW_QOS_QUEUE_PORT_GET.\n"
	"\n"
	"nTrafficClassId :\n"
	"\tTraffic Class index (zero-based counting). This is an input parameter\n"
	"\tfor GSW_QOS_QUEUE_PORT_GET.\n"
	"\n"
	"bRedirectionBypass :\n"
	"\tQueue Redirection bypass Option. If enabled, all packets destined \n"
	"\tto 'nQueueId' are redirected from the 'nPortId' to 'nRedirectPortId'\n"
	"\n"
	"bExtrationEnable :\n"
	"\tExtraction Option. If enabled, packets are extracted to CPU port.\n"
	"\tOnly supported in GSWIP3.1 and above.\n"
	"\n"
	"listunused :\n"
	"\tPrintout a list of all unused and unassigned egress queue.\n"
	"\n",
	/* 65: GSW_QOS_QUEUE_PORT_SET */
	"Sets the Queue ID for one traffic class of one port. The total amount of\n"
	"supported ports, queues and traffic classes can be retrieved from the\n"
	"capability list using GSW_CAP_GET. Please note that the device comes\n"
	"along with a default configuration and assignment.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. This is an input parameter for\n"
	"\tGSW_QOS_QUEUE_PORT_GET.\n"
	"\n"
	"nTrafficClassId :\n"
	"\tTraffic Class index (zero-based counting). This is an input parameter\n"
	"\tfor GSW_QOS_QUEUE_PORT_GET.\n"
	"\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting). This is an output parameter for\n"
	"\tGSW_QOS_QUEUE_PORT_GET.\n"
	"bRedirectionBypass :\n"
	"\tQueue Redirection bypass Option. If enabled, all packets destined \n"
	"\tto 'nQueueId' are redirected from the 'nPortId' to 'nRedirectPortId'\n"
	"\n"
	"nRedirectPortId :\n"
	"\tRedirected traffic forward port.\n"
	"\tThe bRedirectPortId, all packets  from 'nPortId' are redirected.\n"
	"\n",
	/* 66: GSW_QOS_SCHEDULER_CFG_GET */
	"Read out the current scheduler configuration of a given egress port. This\n"
	"configuration can be modified using GSW_QOS_SCHEDULER_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).",
	/* 67: GSW_QOS_SCHEDULER_CFG_SET */
	"This configuration decides how the egress queues, attached to a single port,\n"
	"are scheduled to transmit the queued Ethernet packets. The configuration\n"
	"differentiates between 'Strict Priority' and 'weighted fair queuing'. This\n"
	"applies when multiple egress queues are assigned to an Ethernet port. Using\n"
	"the WFQ feature on a port requires the configuration of weights on all given\n"
	"queues that are assigned to that port. Strict Priority means that no dedicated\n"
	"weight is configured and the queue can transmit following its priority status.\n"
	"The given configuration can be read out using GSW_QOS_SCHEDULER_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).\n"
	"\n"
	"eType :\n"
	"\tScheduler Type (Strict Priority/Weighted Fair Queuing).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Strict Priority.\n"
	"\n"
	"\t1: Weighted Fair Queuing.\n"
	"\n"
	"nWeight :\n"
	"\tWeight in Token. Parameter used for WFQ configuration. Sets the weight\n"
	"\tin token in relation to all remaining queues on this egress port\n"
	"\thaving WFQ configuration. This parameter is only used when\n"
	"\t'eType=GSW_QOS_SCHEDULER_WFQ'.",
	/* 68: GSW_QOS_SHAPER_CFG_GET */
	"This command retrieves the rate and the burst size configuration of a rate\n"
	"shaper instance. A configuration can be modified using\n"
	"GSW_QOS_SHAPER_CFG_SET. The total number of available rate shapers can\n"
	"be retrieved by the capability list using GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"nRateShaperId :\n"
	"\tRate shaper index (zero-based counting).\n"
	"\n"
	"nRate :\n"
	"\tRate [kbit/s]",
	/* 69: GSW_QOS_SHAPER_CFG_SET */
	"This command configures a rate shaper instance with the rate and the burst\n"
	"size. This instance can be assigned to QoS queues by using\n"
	"GSW_QOS_SHAPER_QUEUE_ASSIGN. The total number of available rate shapers\n"
	"can be retrieved by the capability list using GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"nRateShaperId :\n"
	"\tRate shaper index (zero-based counting).\n"
	"\n"
	"bEnable :\n"
	"\tEnable/Disable the rate shaper.\n"
	"\n"
	"bAVB :\n"
	"\t802.1Qav credit based shaper mode. This specific shaper algorithm mode is used\n"
	"\tby the audio/video bridging (AVB)network (according to 802.1Qav). By default, an token \n"
	"\tbased shaper algorithm is used.\n"
	"\n"
	"nCbs :\n"
	"\tCommitted Burst Size (CBS [bytes])\n"
	"\n"
	"nRate :\n"
	"\tRate [kbit/s]",
	/* 70: GSW_QOS_SHAPER_QUEUE_ASSIGN */
	"Assign one rate shaper instance to a QoS queue. The function returns with an\n"
	"error in case there already are too many shaper instances assigned to a queue.\n"
	"The queue instance can be enabled and configured using\n"
	"GSW_QOS_SHAPER_CFG_SET. To remove a rate shaper instance from a QoS\n"
	"queue, please use GSW_QOS_SHAPER_QUEUE_DEASSIGN. The total number of\n"
	"available rate shaper instances can be retrieved by the capability list using\n"
	"GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"nRateShaperId :\n"
	"\tRate shaper index (zero-based counting).\n"
	"\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).",
	/* 71: GSW_QOS_SHAPER_QUEUE_DEASSIGN */
	"Deassign one rate shaper instance from a QoS queue. The function returns with\n"
	"an error in case the requested instance is not currently assigned to the\n"
	"queue. The queue instance can be enabled and configured by using\n"
	"GSW_QOS_SHAPER_CFG_SET. To assign a rate shaper instance to a QoS queue,\n"
	"please use GSW_QOS_SHAPER_QUEUE_ASSIGN. The total number of available\n"
	"rate shapers can be retrieved by the capability list using GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"nRateShaperId :\n"
	"\tRate shaper index (zero-based counting).\n"
	"\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).",
	/* 72: GSW_QOS_SHAPER_QUEUE_GET */
	"Check whether a rate shaper instance is assigned to the egress queue. The\n"
	"egress queue index is the function input parameter. The switch API sets the\n"
	"boolean parameter 'bAssigned == 1' in case a rate shaper is assigned\n"
	"and then sets 'nRateShaperId' to describe the rater shaper instance. The\n"
	"parameter 'bAssigned == 0' in case no rate shaper instance is\n"
	"currently assigned to the queue instance. The commands\n"
	"GSW_QOS_SHAPER_QUEUE_ASSIGN allow a rate shaper instance to be assigned,\n"
	"and GSW_QOS_SHAPER_CFG_SET allows for configuration of a shaper\n"
	"instance. The total number of available rate shapers can be retrieved by the\n"
	"capability list using GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting). This parameter is the input\n"
	"\tparameter for the GET function.",
	/* 73: GSW_QOS_STORM_CFG_GET */
	"Reads out the current meter instance assignment for storm control. This\n"
	"configuration can be modified using GSW_QOS_STORM_CFG_SET.",
	/* 74: GSW_QOS_STORM_CFG_SET */
	"This command configures one meter instances for storm control. These instances\n"
	"can be used for ingress broadcast-, multicast- and unknown unicast- packets.\n"
	"Some platforms support addition of additional meter instances for this type of\n"
	"packet. Repeated calls of GSW_QOS_STORM_CFG_SET allow addition of\n"
	"additional meter instances. An assignment can be retrieved using\n"
	"GSW_QOS_STORM_CFG_GET. Setting the broadcast, multicast and unknown\n"
	"unicast packets boolean switch to zero deletes all metering instance\n"
	"assignments.\n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter index 0 (zero-based counting).\n"
	"\n"
	"bBroadcast :\n"
	"\tMeter instances used for broadcast traffic.\n"
	"\n"
	"bMulticast :\n"
	"\tMeter instances used for multicast traffic.\n"
	"\n"
	"bUnknownUnicast :\n"
	"\tMeter instances used for unknown unicast traffic.",
	/* 75: GSW_QOS_WRED_CFG_GET */
	"Read out the global WRED drop probability profile and thresholds of the\n"
	"device. Given parameters are rounded to the segment size of the HW platform.\n"
	"The supported segment size is given by the capability list by using\n"
	"GSW_CAP_GET.",
	/* 76: GSW_QOS_WRED_CFG_SET */
	"Configures the global WRED drop probability profile and thresholds of the\n"
	"device. Given parameters are rounded to the segment size of the HW platform.\n"
	"The supported segment size is given by the capability list by using\n"
	"GSW_CAP_GET.\n"
	"\nParameter:\n----------\n"
	"eProfile :\n"
	"\tDrop Probability Profile.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Pmin = 25%, Pmax = 75% (default)\n"
	"\n"
	"\t1: Pmin = 25%, Pmax = 50%\n"
	"\n"
	"\t2: Pmin = 50%, Pmax = 50%\n"
	"\n"
	"\t3: Pmin = 50%, Pmax = 75%\n"
	"\n"
	"eMode :\n"
	"\tAutomatic or Manual Mode of Thresholds Config.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Automatic - Adaptive Watermark Type.\n"
	"\n"
	"\t1: Manual Threshold Levels Type.\n"
	"\n"
	"eThreshMode :\n"
	"\tWRED Threshold Mode Config.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Local Thresholds Mode (default)\n"
	"\n"
	"\t1: Global Thresholds Mode\n"
	"\n"
	"nRed_Min :\n"
	"\tWRED Red Threshold Min [number of segments].\n"
	"\n"
	"nRed_Max :\n"
	"\tWRED Red Threshold Max [number of segments].\n"
	"\n"
	"nYellow_Min :\n"
	"\tWRED Yellow Threshold Min [number of segments].\n"
	"\n"
	"nYellow_Max :\n"
	"\tWRED Yellow Threshold Max [number of segments].\n"
	"\n"
	"nGreen_Min :\n"
	"\tWRED Green Threshold Min [number of segments].\n"
	"\n"
	"nGreen_Max :\n"
	"\tWRED Green Threshold Max [number of segments]."
	"\n",
	/* 77: GSW_QOS_WRED_QUEUE_CFG_GET */
	"Read out the WRED drop thresholds for a dedicated egress queue. Given\n"
	"parameters are rounded to the segment size of the HW platform. The supported\n"
	"segment size is given by the capability list by using GSW_CAP_GET. The\n"
	"configuration can be changed by using GSW_QOS_WRED_QUEUE_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting)."
	"\n",
	/* 78: GSW_QOS_WRED_QUEUE_CFG_SET */
	"Configures the WRED drop thresholds for a dedicated egress queue. Given\n"
	"parameters are rounded to the segment size of the HW platform. The supported\n"
	"segment size is given by the capability list by using GSW_CAP_GET. The\n"
	"command GSW_QOS_WRED_QUEUE_CFG_GET retrieves the current configuration.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).\n"
	"\n"
	"nRed_Min :\n"
	"\tWRED Red Threshold Min [number of segments].\n"
	"\n"
	"nRed_Max :\n"
	"\tWRED Red Threshold Max [number of segments].\n"
	"\n"
	"nYellow_Min :\n"
	"\tWRED Yellow Threshold Min [number of segments].\n"
	"\n"
	"nYellow_Max :\n"
	"\tWRED Yellow Threshold Max [number of segments].\n"
	"\n"
	"nGreen_Min :\n"
	"\tWRED Green Threshold Min [number of segments].\n"
	"\n"
	"nGreen_Max :\n"
	"\tWRED Green Threshold Max [number of segments]."
	"\n",
	/* 79: GSW_RMON_CLEAR */
	"Clears an Ethernet port traffic statistic counter (RMON counter).\n"
	"\nParameter:\n----------\n"
	"nRmonId :\n"
	"\tRMON Counters Identifier - Meter, Port, If, Route, etc.\n"
	"eRmonType :\n"
	"\tReset the RMON Counters Type.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: All RMON Types Counters (GSW_RMON_ALL_TYPE). \n"
	"\n"
	"\t1: All PMAC RMON Counters (GSW_RMON_PMAC_TYPE).\n"
	"\n"
	"\t2: Port based RMON Counters (GSW_RMON_PORT_TYPE).\n"
	"\n"
	"\t3: Meter based RMON Counters (GSW_RMON_METER_TYPE).\n"
	"\n"
	"\t4: Interface based RMON Counters(GSW_RMON_IF_TYPE).\n"
	"\n"
	"\t5: Route based RMON Counters (GSW_RMON_ROUTE_TYPE).\n"
	"\n"
	"\t6: Redirected Traffic based RMON Counters (GSW_RMON_REDIRECT_TYPE).\n"
	"\n",
	/* 80: GSW_RMON_PORT_GET */
	"Read out the Ethernet port statistic counter (RMON counter). The zero-based\n"
	"'nPortId' structure element describes the logical/ctp/bridge switch port for the\n"
	"requested statistic information.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. This parameter specifies for which MAC port the RMON1\n"
	"\tcounter is read. It has to be set by the application before calling\n"
	"\tGSW_RMON_PORT_GET\n"
	"ePortType :\n"
	"\tPort Type. This gives information which type of port to get RMON.\n"
	"\tnPortId should be based on this field.\n"
	"\tThis is new in GSWIP-3.1. For GSWIP-2.1/2.2/3.0, this field is always\n"
	"\tZERO (GSW_LOGICAL_PORT).\n"
	"nSubIfIdGroup :\n"
	"\tremarks"
	"\tThis field is valid when \ref GSW_RMON_Port_cnt_t::ePortType is\n"
	"\tGSW_portType_t::GSW_CTP_PORT.\n"
	"\tSub interface ID group is defined for each of \ref GSW_LogicalPortMode_t.\n"
	"\tFor both GSW_LOGICAL_PORT_8BIT_WLAN and\n"
	"\tGSW_LOGICAL_PORT_9BIT_WLAN, this field is VAP.\n"
	"\tFor GSW_LOGICAL_PORT_GPON, this field is GEM index.\n"
	"\tFor GSW_LOGICAL_PORT_EPON, this field is stream index.\n"
	"\tFor GSW_LOGICAL_PORT_GINT, this field is LLID.\n"
	"\tFor others, this field is 0.\n"
	"bPceBypass :\n"
	"\tSeparate set of CTP Tx counters when PCE is bypassed. GSWIP-3.1 only\n",
	/* 81: GSW_STP_BPDU_RULE_GET */
	"Read the Spanning Tree configuration. The configuration can be modified using\n"
	"GSW_STP_BPDU_RULE_SET.",
	/* 82: GSW_STP_BPDU_RULE_SET */
	"Set the Spanning Tree configuration. This configuration includes the filtering\n"
	"of detected spanning tree packets. These packets could be redirected to one\n"
	"dedicated port (e.g. CPU port) or they could be discarded. The current\n"
	"configuration can be read using GSW_STP_BPDU_RULE_GET.\n"
	"\nParameter:\n----------\n"
	"eForwardPort :\n"
	"\tFilter spanning tree packets and forward them, discard them or disable\n"
	"\tthe filter.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Default; portmap is determined by the forwarding classification.\n"
	"\n"
	"\t1: Discard; discard packets.\n"
	"\n"
	"\t2: Forward to the CPU port. This requires that the CPU port is\n"
	"\t\tpreviously set by calling GSW_CPU_PORT_CFG_SET.\n"
	"\n"
	"\t3: Forward to a port, selected by the parameter 'nForwardPortId'.\n"
	"\t\tPlease note that this feature is not supported by all hardware\n"
	"\t\tplatforms.\n"
	"\n"
	"nForwardPortId :\n"
	"\tTarget port for forwarded packets; only used if selected by\n"
	"\t'eForwardPort'. Forwarding is done if 'eForwardPort =\n"
	"\tGSW_PORT_FORWARD_PORT'.",
	/* 83: GSW_STP_PORT_CFG_GET */
	"Read out the current Spanning Tree Protocol state of an Ethernet port. This\n"
	"configuration can be set using GSW_STP_PORT_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 84: GSW_STP_PORT_CFG_SET */
	"Configure the Spanning Tree Protocol state of an Ethernet port. The switch\n"
	"supports four Spanning Tree Port states (Disable/Discarding,\n"
	"Blocking/Listening, Learning and Forwarding state) for every port, to enable\n"
	"the Spanning Tree Protocol function when co-operating with software on the CPU\n"
	"port. Identified Spanning Tree Protocol packets can be redirected to the CPU\n"
	"port. Depending on the hardware implementation, the CPU port assignement is\n"
	"fixed or can be configured using GSW_CPU_PORT_CFG_SET. The current port\n"
	"state can be read back using GSW_STP_PORT_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"nFId :\n"
	"\tFiltering Identifier (FID) (not supported by all switches). The FID allows to keep\n"
	"\t multiple STP states per physical Ethernet port. Multiple CTAG VLAN groups could be a \n"
	"\tassigned to one FID and therefore share the same STP port state. Switch API ignores \n"
	"\tthe FID value in case the switch device does not support it or switch CTAG VLAN \n"
	"\tawareness is disabled. \n"
	"\n"
	"ePortState :\n"
	"\tSpanning Tree Protocol state of the port.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Forwarding state. The port is allowed to transmit and receive all\n"
	"\t\tpackets. Address Learning is allowed.\n"
	"\n"
	"\t1: Disabled/Discarding state. The port entity will not transmit and\n"
	"\t\treceive any packets. Learning is disabled in this state.\n"
	"\n"
	"\t2: Learning state. The port entity will only transmit and receive\n"
	"\t\tSpanning Tree Protocol packets (BPDU). All other packets are\n"
	"\t\tdiscarded. MAC table address learning is enabled for all good\n"
	"\t\tframes.\n"
	"\n"
	"\t3: Blocking/Listening. Only the Spanning Tree Protocol packets will be\n"
	"\t\treceived and transmitted. All other packets are discarded by the\n"
	"\t\tport entity. MAC table address learning is disabled in this state.",
	/* 85: GSW_VERSION_GET */
	"Retrieve the version string of the currently version index. The returned\n"
	"string format might vary between the device platforms used. This means that\n"
	"the version information cannot be compared between different device platforms.\n"
	"All returned version information is in the form of zero-terminated character\n"
	"strings. The returned strings are empty ('') in case the given version index\n"
	"is out of range.",
	/* 86: GSW_VLAN_ID_CREATE */
	"Add a VLAN ID group to the active VLAN set of the Ethernet switch hardware.\n"
	"Based on this configuration, VLAN group port members can be added using\n"
	"GSW_VLAN_PORT_MEMBER_ADD. The VLAN ID configuration can be removed again\n"
	"by calling GSW_VLAN_ID_DELETE.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVLAN ID. The valid range is from 0 to 4095. An error code is delivered\n"
	"\tin case of range mismatch.\n"
	"\n"
	"nFId :\n"
	"\tFiltering Identifier (FID) (not supported by all switches).",
	/* 87: GSW_VLAN_ID_DELETE */
	"Remove a VLAN ID group from the active VLAN set of the switch hardware. The\n"
	"VLAN ID group was set using GSW_VLAN_ID_CREATE. A VLAN ID group can only\n"
	"be removed when no port group members are currently configured on the\n"
	"hardware. This VLAN ID group membership configuration is done using\n"
	"GSW_VLAN_PORT_MEMBER_ADD and can be removed again using\n"
	"GSW_VLAN_PORT_MEMBER_REMOVE.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVLAN ID. The valid range is from 0 to 4095. An error code is delivered\n"
	"\tin case of range mismatch.",
	/* 88: GSW_VLAN_ID_GET */
	"Read out the FID of a given VLAN ID. This VLAN ID can be added using\n"
	"GSW_VLAN_ID_CREATE. This function returns an error in case no valid\n"
	"configuration is available for the given VLAN ID.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVLAN ID. The valid range is from 0 to 4095. An error code is delivered\n"
	"\tin case of range mismatch.",
	/* 89: GSW_VLAN_PORT_CFG_GET */
	"Get VLAN Port Configuration. This function returns the VLAN configuration of\n"
	"the given Port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 90: GSW_VLAN_PORT_CFG_SET */
	"Set VLAN Port Configuration. This function sets the VLAN configuration of the\n"
	"given Port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"nPortVId :\n"
	"\tPort VLAN ID (PVID). The software shall ensure that the used VLAN has\n"
	"\tbeen configured in advance on the hardware by using\n"
	"\tGSW_VLAN_ID_CREATE.\n"
	"\n"
	"bVLAN_UnknownDrop :\n"
	"\tDrop ingress VLAN-tagged packets if the VLAN ID is not listed in the\n"
	"\tactive VLAN set. If disabled, all incoming VLAN-tagged packets are\n"
	"\tforwarded using the FID tag members and the port members of the PVID.\n"
	"\n"
	"bVLAN_ReAssign :\n"
	"\tReassign all ingress VLAN tagged packets to the port-based VLAN ID\n"
	"\t(PVID).\n"
	"\n"
	"eVLAN_MemberViolation :\n"
	"\tVLAN ingress and egress membership violation mode. Allows admittance\n"
	"\tof VLAN-tagged packets where the port is not a member of the VLAN ID\n"
	"\tcarried in the received and sent packet.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No VLAN member violation. Ingress and egress packets violating the\n"
	"\t\tmembership pass and are not filtered out.\n"
	"\n"
	"\t1: VLAN member violation for ingress packets. Ingress packets\n"
	"\t\tviolating the membership are filtered out. Egress packets violating\n"
	"\t\tthe membership are not filtered out.\n"
	"\n"
	"\t2: VLAN member violation for egress packets. Egress packets violating\n"
	"\t\tthe membership are filtered out. Ingress packets violating the\n"
	"\t\tmembership are not filtered out.\n"
	"\n"
	"\t3: VLAN member violation for ingress and egress packets. Ingress and\n"
	"\t\tegress packets violating the membership are filtered out.\n"
	"\n"
	"eAdmitMode :\n"
	"\tIngress VLAN-tagged or untagged packet filter configuration.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Admit all. Tagged and untagged packets are allowed.\n"
	"\n"
	"\t1: Untagged packets only (not supported yet). Tagged packets are\n"
	"\t\tdropped.\n"
	"\n"
	"\t2: Tagged packets only. Untagged packets are dropped.\n"
	"\n"
	"bTVM :\n"
	"\tTransparent VLAN Mode (TVM). All packets are handled as untagged\n"
	"\tpackets. Any existing tag is ignored and treated as packet payload.",
	/* 91: GSW_VLAN_PORT_MEMBER_ADD */
	"Add Ethernet port to port members of a given VLAN group. The assignment can be\n"
	"removed using GSW_VLAN_PORT_MEMBER_REMOVE.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVLAN ID. The valid range is from 0 to 4095. An error code is delivered\n"
	"\tin case of range mismatch.\n"
	"\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bVLAN_TagEgress :\n"
	"\tTag Member Egress. Enable egress tag-based support. If enabled, all\n"
	"\tport egress traffic from this VLAN group carries a VLAN group tag.",
	/* 92: GSW_VLAN_PORT_MEMBER_READ */
	"Read out all given VLAN group port memberships. Every command call returns one\n"
	"VLAN and port membership pair with the corresponding egress traffic tag\n"
	"behavior. Call the command in a loop till Switch API sets the 'bLast' variable\n"
	"to read all VLAN port memberships. Please set the 'bInitial' parameter for the\n"
	"first call starting the read operation at the beginning of the VLAN table.",
	/* 93: GSW_VLAN_PORT_MEMBER_REMOVE */
	"Remove Ethernet port from port members of a given VLAN group. This assignment\n"
	"was done using GSW_VLAN_PORT_MEMBER_ADD.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVLAN ID. The valid range is from 0 to 4095. An error code is delivered\n"
	"\tin case of range mismatch. If the selected VLAN ID is not found in the\n"
	"\tvLAN table, an error code is delivered.\n"
	"\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available."
	"\n",
	/* 94: GSW_VLAN_MEMBER_INIT */
	"Initializes the VLAN membership and the egress tagged portmap of all VLAN groups.\n"
	"\nParameter:\n----------\n"
	"nPortMemberMap :\n"
	"\tPortmap field of the uninitialized VLAN groups.\n"
	"\n"
	"nEgressTagMap :\n"
	"\tEgress tagmap field of the uninitialized VLAN groups.\n"
	"\n",
	/* 95: GSW_VLAN_RESERVED_ADD */
	"Add VLAN ID to a reserved VLAN list. The switch supports replacing the VID of\n"
	"received packets with the PVID of the receiving port. This function adds a VID\n"
	"to the list of VIDs to replace. All switch devices support adding VID=0, VID=1\n"
	"and VID=FFF to be replaced. Some devices also allow adding other VIDs to be\n"
	"replaced. An added VID could be removed again by calling\n"
	"GSW_VLAN_RESERVED_REMOVE. This configuration applies to the whole switch\n"
	"device.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVID of the received packet to be replaced by the PVID. The valid range\n"
	"\tis from 0 to 4095. An error code is delivered in case of range\n"
	"\tmismatch.",
	/* 96: GSW_VLAN_RESERVED_REMOVE */
	"Remove VLAN ID from a reserved VLAN group list. This function removes a VID\n"
	"replacement configuration from the switch hardware. This replacement\n"
	"configuration replaces the VID of received packets with the PVID of the\n"
	"receiving port. This configuration can be added using\n"
	"GSW_VLAN_RESERVED_ADD. This configuration applies to the whole switch\n"
	"device.\n"
	"\nParameter:\n----------\n"
	"nVId :\n"
	"\tVID of the received packet to be replaced by the PVID. The valid range\n"
	"\tis from 0 to 4095. An error code is delivered in case of range\n"
	"\tmismatch.",
	/* 97: GSW_WOL_CFG_GET */
	"Read the Wake-on-LAN configuration. The parameters can be modified using\n"
	"GSW_WOL_CFG_SET.",
	/* 98: GSW_WOL_CFG_SET */
	"Set the Wake-on-LAN configuration. The parameters can be read using\n"
	"GSW_WOL_CFG_GET.\n"
	"\nParameter:\n----------\n"
	"nWolMAC :\n"
	"\tWoL MAC address.\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"nWolPassword :\n"
	"\tWoL password.\n"
	"\n"
	"bWolPasswordEnable :\n"
	"\tWoL password enable.",
	/* 99: GSW_WOL_PORT_CFG_GET */
	"Read out the current status of the Wake-On-LAN feature on a dedicated port.\n"
	"This status can be changed using GSW_WOL_PORT_CFG_SET. The Wake-On-LAN\n"
	"specific parameter can be configured using GSW_WOL_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 100: GSW_WOL_PORT_CFG_SET */
	"Set the current Wake-On-LAN status for a dedicated port. The Wake-On-LAN\n"
	"specific parameter can be configured using GSW_WOL_CFG_SET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bWakeOnLAN_Enable :\n"
	"\tEnable Wake-on-LAN.",
	/* 101: GSW_IRQ_GET */
	"Read the interrupt status. Interrupt status indications can be cleared using\n"
	"GSW_IRQ_STATUS_CLEAR.",
	/* 102: GSW_IRQ_MASK_GET */
	"Get the interrupt enable configuration. This assignment can be set using\n"
	"GSW_IRQ_MASK_SET.",
	/* 103: GSW_IRQ_MASK_SET */
	"Set the interrupt enable configuration. This assignment can be read using\n"
	"GSW_IRQ_MASK_GET. Setting interrupts that are not supported by hardware\n"
	"results in an error response.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. This port parameter is needed for some interrupts that\n"
	"\tare specified by 'nIrqSrc'. For all other interrupts, this parameter\n"
	"\tis \"don't care\".\n"
	"\n"
	"eIrqSrc :\n"
	"\tInterrupt source.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Wake-on-LAN Interrupt. The parameter 'nPortId' specifies the\n"
	"\t\trelative MAC port.\n"
	"\n"
	"\t1: Port Limit Alert Interrupt. This interrupt is asserted when the\n"
	"\t\tnumber of learned MAC addresses exceeds the configured limit for\n"
	"\t\tthe ingress port. The parameter 'nPortId' specifies the relative\n"
	"\t\tMAC port.\n"
	"\n"
	"\t2: Port Lock Alert Interrupt. This interrupt is asserted when a source\n"
	"\t\tMAC address is learned on a locked port and is received on another\n"
	"\t\tport. The parameter 'nPortId' specifies the relative MAC port.",
	/* 104: GSW_IRQ_STATUS_CLEAR */
	"Clear individual interrupt status bits. Interrupt status indications can be\n"
	"read using GSW_IRQ_GET.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. This port parameter is needed for some interrupts that\n"
	"\tare specified by 'nIrqSrc'. For all other interrupts, this parameter\n"
	"\tis \"don't care\".\n"
	"\n"
	"eIrqSrc :\n"
	"\tInterrupt source.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Wake-on-LAN Interrupt. The parameter 'nPortId' specifies the\n"
	"\t\trelative MAC port.\n"
	"\n"
	"\t1: Port Limit Alert Interrupt. This interrupt is asserted when the\n"
	"\t\tnumber of learned MAC addresses exceeds the configured limit for\n"
	"\t\tthe ingress port. The parameter 'nPortId' specifies the relative\n"
	"\t\tMAC port.\n"
	"\n"
	"\t2: Port Lock Alert Interrupt. This interrupt is asserted when a source\n"
	"\t\tMAC address is learned on a locked port and is received on another\n"
	"\t\tport. The parameter 'nPortId' specifies the relative MAC port.",
	/* 105: GSW_PCE_RULE_DELETE */
	"This command deletes a complete rule from the packet classification engine. A\n"
	"delete operation is done on the rule of a dedicated index 'nIndex'. A rule can\n"
	"be written over using the command GSW_PCE_RULE_WRITE.\n"
	"\nParameter:\n----------\n"
	"nIndex :\n"
	"\tAction Index in the Packet Classification Engine. It corresponds to\n"
	"\tthe table rule index."
	"\n",
	/* 106: GSW_PCE_RULE_READ */
	"This command allows to read out a rule pattern and action of the packet\n"
	"classification engine. A rule could be written by the command\n"
	"GSW_PCE_RULE_WRITE.\n"
	"Parameter:\n----------\n"
	"pattern.nIndex :\n"
	"\tTable index"
	"\n",
	/* 107: GSW_PCE_RULE_WRITE */
	"This command writes a rule pattern and action to the table of the packet\n"
	"classification engine. The pattern part describes the parameter to identify an\n"
	"incoming packet to which the dedicated actions should be applied. A rule can\n"
	"be read using the command GSW_PCE_RULE_READ.\n"
	"Rule Pattern Part.\n"
	"\nParameter:\n----------\n"
	"pattern.nIndex :\n"
	"\tPCE Rule Index (Upto 512 rules supported in GSWIP-3.0)\n"
	"\n"
	"pattern.bEnable :\n"
	"\tIndex is used (enabled) or set to unused (disabled)\n"
	"\n"
	"pattern.bPortIdEnable :\n"
	"\tPort ID used\n"
	"\n"
	"pattern.nPortId :\n"
	"\tPort ID\n"
	"\n"
	"pattern.bPortId_Exclude :\n"
	"\tExclude Port Id Value - used for GSWIP-3.0 only\n"
	"\n"

	"pattern.bSubIfIdEnable :\n"
	"\tSub-Interface ID - used for GSWIP-3.0 only\n"
	"\n"
	"pattern.nSubIfId :\n"
	"\tSub-Interface ID value - used for GSWIP-3.0 only \n"
	"\n"
	"pattern.bSubIfId_Exclude :\n"
	"\tExclude Sub-Interface Id Value - used for GSWIP-3.0 only\n"
	"\n"

	"pattern.bDSCP_Enable :\n"
	"\tDSCP value used (Outer for GSWIP-3.0)\n"
	"\n"
	"pattern.nDSCP :\n"
	"\tDSCP value (Outer for GSWIP-3.0)\n"
	"\n"
	"pattern.bDSCP_Exclude :\n"
	"\tExclude (Outer) DSCP value used for GSWIP-3.0 only\n"
	"\n"
	"pattern.bInner_DSCP_Enable :\n"
	"\tInner DSCP value used for GSWIP-3.0 only \n"
	"\n"
	"pattern.nInnerDSCP :\n"
	"\tInner DSCP value  for GSWIP-3.0 only \n"
	"\n"
	"pattern.bInnerDSCP_Exclude :\n"
	"\tExclude Inner DSCP value used for GSWIP-3.0 only\n"
	"\n"

	"pattern.bPCP_Enable :\n"
	"\tPCP value used\n"
	"\n"
	"pattern.nPCP :\n"
	"\tPCP value\n"
	"\n"
	"pattern.bCTAG_PCP_DEI_Exclude :\n"
	"\tExclude CTAG PCP & DEI value used for GSWIP-3.0 only\n"
	"\n"

	"pattern.bSTAG_PCP_DEI_Enable :\n"
	"\tSTAG VLAN PCP/DEI value used \n"
	"\n"
	"pattern.nSTAG_PCP_DEI :\n"
	"\tSTAG VLAN PCP value\n"
	"\n"

	"pattern.bSTAG_PCP_DEI_Exclude :\n"
	"\tExclude STAG PCP & DEI value used for GSWIP-3.0 only\n"
	"\n"

	"pattern.bPktLngEnable :\n"
	"\tPacket length used\n"
	"\n"
	"pattern.nPktLng :\n"
	"\tPacket length\n"
	"\n"
	"pattern.nPktLngRange :\n"
	"\tPacket length Range (from nPktLng to nPktLngRange)\n"
	"\n"

	"pattern.bPktLng_Exclude :\n"
	"\tExclude Packet Length or range value used for GSWIP-3.0 only \n"
	"\n"

	"pattern.bMAC_DstEnable :\n"
	"\tDestination MAC address used\n"
	"\n"
	"pattern.nMAC_Dst :\n"
	"\tDestination MAC address\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"pattern.nMAC_DstMask :\n"
	"\tDestination MAC address mask. Please clear the bits of the nibbles\n"
	"\tthat are not marked out and set all other bits. The LSB bit represents\n"
	"\tthe lowest data nibble, the next bit the next nibble, and so on.\n"
	"\n"

	"pattern.bDstMAC_Exclude :\n"
	"\tExclude Destination MAC Address used for GSWIP-3.0 only \n"
	"\n"

	"pattern.bMAC_SrcEnable :\n"
	"\tSource MAC address used\n"
	"\n"
	"pattern.nMAC_Src :\n"
	"\tSource MAC address\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"pattern.nMAC_SrcMask :\n"
	"\tSource MAC address mask. Please clear the bits of the nibbles that are\n"
	"\tnot marked out and set all other bits. The LSB bit represents the\n"
	"\tlowest data nibble, the next bit the next nibble, and so on.\n"
	"\n"

	"pattern.bSrcMAC_Exclude :\n"
	"\tExclude Source MAC Address used for GSWIP-3.0 only \n"
	"\n"

	"pattern.bAppDataMSB_Enable :\n"
	"\tMSB Application field used\n"
	"\n"
	"pattern.nAppDataMSB :\n"
	"\tMSB Application field. The first 2 bytes of the packet content\n"
	"\tfollowing the IP header for TCP/UDP packets (source port field), or\n"
	"\tthe first 2 bytes of packet content following the Ethertype for non-IP\n"
	"\tpackets. Any part of this content can be masked-out by a programmable\n"
	"\tbit mask 'nAppMaskRangeMSB'.\n"
	"\n"
	"pattern.bAppMaskRangeMSB_Select :\n"
	"\tMSB Application mask/range selection. If set to 1, the field\n"
	"\t'nAppMaskRangeMSB' is used as a range parameter, otherwise it is used\n"
	"\tas a nibble mask field.\n"
	"\n"
	"pattern.nAppMaskRangeMSB :\n"
	"\tMSB Application mask/range. When used as a range parameter, 1 bit\n"
	"\trepresents 1 nibble mask of the 'nAppDataMSB' field. Please clear the\n"
	"\tbits of the nibbles that are not marked out and set all other bits.\n"
	"\tThe LSB bit represents the lowest data nibble, the next bit the next\n"
	"\tnibble, and so on.\n"
	"\n"

	"pattern.bAppMSB_Exclude :\n"
	"\tMSB Application Data Exclude - for GSWIP-3.0 only \n"
	"\n"

	"pattern.bAppDataLSB_Enable :\n"
	"\tLSB Application used\n"
	"\n"
	"pattern.nAppDataLSB :\n"
	"\tLSB Application field. The following 2 bytes of the packet behind the\n"
	"\t'nAppDataMSB' field. This is the destination port field for TCP/UDP\n"
	"\tpackets, or byte 3 and byte 4 of the packet content following the\n"
	"\tEthertype for non-IP packets. Any part of this content can be\n"
	"\tmasked-out by a programmable bit mask 'nAppMaskRangeLSB'.\n"
	"\n"
	"pattern.bAppMaskRangeLSB_Select :\n"
	"\tLSB Application mask/range selection. If set to 1, the field\n"
	"\t'nAppMaskRangeLSB' is used as a range parameter, otherwise it is used\n"
	"\tas a nibble mask field.\n"
	"\n"
	"pattern.nAppMaskRangeLSB :\n"
	"\tLSB Application mask/range. When used as a range parameter, 1 bit\n"
	"\trepresents 1 nibble mask of the 'nAppDataLSB' field. Please clear the\n"
	"\tbits of the nibbles that are not marked out and set all other bits.\n"
	"\tThe LSB bit represents the lowest data nibble, the next bit the next\n"
	"\tnibble, and so on.\n"
	"\n"

	"pattern.bAppLSB_Exclude :\n"
	"\tLSB Application Data Exclude - for GSWIP-3.0 only \n"
	"\n"

	"pattern.eDstIP_Select :\n"
	"\tDestination IP Selection (Outer for GSWIP-3.0).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Rule Pattern for IP selection disabled.\n"
	"\n"
	"\t1: Rule Pattern for IPv4.\n"
	"\n"
	"\t2: Rule Pattern for IPv6.\n"
	"\n"
	"pattern.nDstIP :\n"
	"\tDestination IP (Outer for GSWIP-3.0)\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"pattern.nDstIP_Mask :\n"
	"\tDestination IP Nibble Mask. 1 bit represents 1 nibble mask of the 'nDstIP' field.\n"
	"\tPlease clear the bits of the nibbles that are not marked out and set\n"
	"\tall other bits. The LSB bit represents the lowest data nibble, the\n"
	"\tnext bit the next nibble, and so on.\n"
	"\n"
	"pattern.bDstIP_Exclude :\n"
	"\tExclude Destination IP Value - used for GSWIP-3.0 only\n"
	"\n"

	"pattern.eInnerDstIP_Select :\n"
	"\tInner Destination IP Selection - for GSWIP-3.0 only. \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Rule Pattern for IP selection disabled.\n"
	"\n"
	"\t1: Rule Pattern for IPv4.\n"
	"\n"
	"\t2: Rule Pattern for IPv6.\n"
	"\n"
	"pattern.nInnerDstIP :\n"
	"\tInner Destination IP  - for GSWIP-3.0 only.\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"pattern.nInnerDstIP_Mask :\n"
	"\tInner Destination IP Nibble Mask - for GSWIP-3.0 only. 1 bit represents 1 nibble mask of the 'nInnerDstIP' field.\n"
	"\tPlease clear the bits of the nibbles that are not marked out and set\n"
	"\tall other bits. The LSB bit represents the lowest data nibble, the\n"
	"\tnext bit the next nibble, and so on.\n"
	"\n"
	"pattern.bInnerDstIP_Exclude :\n"
	"\tExclude Destination IP Value - used for GSWIP-3.0 only\n"
	"\n"

	"pattern.eSrcIP_Select :\n"
	"\tSource IP Selection (Outer for GSWIP-3.0).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Rule Pattern for IP selection disabled.\n"
	"\n"
	"\t1: Rule Pattern for IPv4.\n"
	"\n"
	"\t2: Rule Pattern for IPv6.\n"
	"\n"
	"pattern.nSrcIP :\n"
	"\tSource IP  (Outer for GSWIP-3.0).\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"pattern.nSrcIP_Mask :\n"
	"\tSource IP Nibble Mask (Outer for GSWIP-3.0). 1 bit represents 1 nibble mask of the 'nSrcIP' field.\n"
	"\tPlease clear the bits of the nibbles that are not marked out and set\n"
	"\tall other bits. The LSB bit represents the lowest data nibble, the\n"
	"\tnext bit the next nibble, and so on.\n"
	"\n"

	"pattern.bSrcIP_Exclude :\n"
	"\tExclude Source IP Value - used for GSWIP-3.0 only\n"
	"\n"

	"pattern.eInnerSrcIP_Select :\n"
	"\tInner Source IP Selection - for GSWIP-3.0 only.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Rule Pattern for IP selection disabled.\n"
	"\n"
	"\t1: Rule Pattern for IPv4.\n"
	"\n"
	"\t2: Rule Pattern for IPv6.\n"
	"\n"
	"pattern.nInnerSrcIP :\n"
	"\tInner Source IP  - for GSWIP-3.0 only.\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"pattern.nInnerSrcIP_Mask :\n"
	"\tInner Src IP Nibble Mask - for GSWIP-3.0 only.. 1 bit represents 1 nibble mask of the 'nInnerSrcIP' field.\n"
	"\tPlease clear the bits of the nibbles that are not marked out and set\n"
	"\tall other bits. The LSB bit represents the lowest data nibble, the\n"
	"\tnext bit the next nibble, and so on.\n"
	"\n"

	"pattern.bInnerSrcIP_Exclude :\n"
	"\tExclude Inner Source IP Value - used for GSWIP-3.0 only \n"
	"\n"


	"pattern.bEtherTypeEnable :\n"
	"\tEthertype used.\n"
	"\n"
	"pattern.nEtherType :\n"
	"\tEthertype\n"
	"\n"
	"pattern.nEtherTypeMask :\n"
	"\tEthertype Mask. 1 bit represents 1 nibble mask of the 'nEtherType'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"

	"pattern.bEtherType_Exclude :\n"
	"\tExclude for Ether Type Value - used for GSWIP-3.0 only.\n"
	"\n"


	"pattern.bProtocolEnable :\n"
	"\tIP protocol used\n"
	"\n"
	"pattern.nProtocol :\n"
	"\tIP protocol\n"
	"\n"
	"pattern.nProtocolMask :\n"
	"\tIP protocol Mask. 1 bit represents 1 nibble mask of the 'nProtocol'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"
	"pattern.bProtocol_Exclude :\n"
	"\tExclude for IP Protocol Value - used for GSWIP-3.0 only.\n"
	"\n"

	"pattern.bInnerProtocolEnable :\n"
	"\tInner IP protocol used - for GSWIP-3.0 only\n"
	"\n"
	"pattern.nInnerProtocol :\n"
	"\tInner IP protocol Value - for GSWIP-3.0 only.\n"
	"\n"
	"pattern.nInnerProtocolMask :\n"
	"\tInner IP protocol Bit Mask - for GSWIP-3.0 only.. 1 bit represents 1 nibble mask of the 'nInnerProtocol'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"
	"pattern.bInnerProtocol_Exclude :\n"
	"\tExclude for Inner IP Protocol Value - used for GSWIP-3.0 only.\n"
	"\n"

	"pattern.bSessionIdEnable :\n"
	"\tPPPoE used.\n"
	"\n"
	"pattern.nSessionId :\n"
	"\tPPPoE\n"
	"\n"

	"pattern.bSessionId_Exclude :\n"
	"\tExclude for PPPoE Session Value - used for GSWIP-3.0 only.\n"
	"\n"

	"pattern.bPPP_ProtocolEnable :\n"
	"\tPPP Protocol used - used for GSWIP-3.0 only.\n"
	"\n"
	"pattern.nPPP_Protocol :\n"
	"\tPPP Protocol Value  - used for GSWIP-3.0 only.\n"
	"\n"
	"pattern.nPPP_ProtocolMask :\n"
	"\tPPP protocol Bit Mask - for GSWIP-3.0 only. 1 bit represents 1 nibble mask of the 'nPPP_Protocol'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"
	"pattern.bPPP_Protocol_Exclude :\n"
	"\tExclude for PPP Protocol Value - used for GSWIP-3.0 only.\n"
	"\n"


	"pattern.bVid :\n"
	"\tVLAN ID used.\n"
	"\n"
	"pattern.nVid :\n"
	"\tVLAN ID\n"
	"\n"

	"pattern.bVidRange_Select :\n"
	"\tVid mask/range selection - used for GSWIP-3.0 only. \n"
	"\n"
	"pattern.nVidRange :\n"
	"\tVLAN ID Range(CVID) - used for GSWIP-3.0 only.\n"
	"\n"

	"pattern.bVid_Exclude :\n"
	"\tExclude for VLAN Id (CVLAN) - used for GSWIP-3.0 only. \n"
	"\n"

	"pattern.bSLAN_Vid :\n"
	"\tSTAG VLAN ID used.\n"
	"\n"
	"pattern.nSLAN_Vid :\n"
	"\tSTAG VLAN ID\n"
	"\n"

	"pattern.bSLANVid_Exclude :\n"
	"\tExclude for SVLAN Id (SVLAN) - used for GSWIP-3.0 only.\n"
	"\n"

	"pattern.bVid_Original :\n"
	"\tbVid_Original\n"
	"\n"

	"pattern.nOuterVidRange :\n"
	"\tnOuterVidRange\n"
	"\n"

	"pattern.bSVidRange_Select :\n"
	"\tbSVidRange_Select\n"
	"\n"

	"pattern.bOuterVid_Original :\n"
	"\tbOuterVid_Original\n"
	"\n"

	"pattern.bPayload1_SrcEnable :\n"
	"\tPayload-1 used - for GSWIP-3.0 PAE only .\n"
	"\n"
	"pattern.nPayload1 :\n"
	"\tPayload-1 Value (16-bits) - for GSWIP-3.0 PAE only.\n"
	"\n"
	"pattern.bPayload1MaskRange_Select :\n"
	"\tPayload-1 mask select used - for GSWIP-3.0 PAE only .\n"
	"\n"
	"pattern.nPayload1_Mask :\n"
	"\tPayload-1 Bit mask - for GSWIP-3.0 PAE only. 1 bit represents 1 nibble mask of the 'nPayload1'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"
	"pattern.bPayload1_Exclude :\n"
	"\tExclude Payload-1 used for GSWIP-3.0 PAE only.\n"
	"\n"

	"pattern.bPayload2_SrcEnable :\n"
	"\tPayload-2 used - for GSWIP-3.0 PAE only.\n"
	"\n"
	"pattern.nPayload2 :\n"
	"\tPayload-2 Value (16-bits) - for GSWIP-3.0 PAE only.\n"
	"\n"
	"pattern.bPayload2MaskRange_Select :\n"
	"\tPayload-2 mask select used - for GSWIP-3.0 PAE only .\n"
	"\n"
	"pattern.nPayload2_Mask :\n"
	"\tPayload-2 Bit mask - for GSWIP-3.0 PAE only. 1 bit represents 1 nibble mask of the 'nPayload2'\n"
	"\tfield. Please clear the bits of the nibbles that are not marked out\n"
	"\tand set all other bits. The LSB bit represents the lowest data nibble,\n"
	"\tthe next bit the next nibble, and so on.\n"
	"\n"
	"pattern.bPayload2_Exclude :\n"
	"\tExclude Payload-2 used for GSWIP-3.0 PAE only.\n"
	"\n"

	"pattern.bParserFlagLSB_Enable :\n"
	"\tParser Flag LSB (Bit 15 to 0) is used\n"
	"\n"
	"pattern.nParserFlagLSB :\n"
	"\tParser Flag LSB Value \n"
	"\n"
	"pattern.nParserFlagLSB_Mask :\n"
	"\tParser Flag LSB Mask Value \n"
	"\n"
	"pattern.bParserFlagLSB_Exclude :\n"
	"\tExclude for Parser Flag LSB.\n"
	"\n"

	"pattern.bParserFlagMSB_Enable :\n"
	"\tParser Flag MSB (Bit 31 to 16) is used\n"
	"\n"
	"pattern.nParserFlagMSB :\n"
	"\tParser Flag MSB Value.\n"
	"\n"
	"pattern.nParserFlagMSB_Mask :\n"
	"\tParser Flag MSB Mask Value \n"
	"\n"
	"pattern.bParserFlagMSB_Exclude :\n"
	"\tExclude for Parser Flag MSB.\n"
	"\n"

	"pattern.bParserFlag1LSB_Enable :\n"
	"\tParser Flag1 LSB (Bit 47 to 32) is used\n"
	"\n"
	"pattern.nParserFlag1LSB :\n"
	"\tParser Flag1 LSB Value \n"
	"\n"
	"pattern.nParserFlag1LSB_Mask :\n"
	"\tParser Flag1 LSB Mask Value \n"
	"\n"
	"pattern.bParserFlag1LSB_Exclude :\n"
	"\tExclude for Parser Flag1 LSB.\n"
	"\n"

	"pattern.bParserFlag1MSB_Enable :\n"
	"\tParser Flag1 MSB (Bit 63 to 48) is used\n"
	"\n"
	"pattern.nParserFlag1MSB :\n"
	"\tParser Flag1 MSB Value.\n"
	"\n"
	"pattern.nParserFlag1MSB_Mask :\n"
	"\tParser Flag1 MSB Mask Value \n"
	"\n"
	"pattern.bParserFlag1MSB_Exclude :\n"
	"\tExclude for Parser Flag1 MSB.\n"
	"\n"

	"Rule Action Part.\n"
	"action.eTrafficClassAction :\n"
	"\tAction \"Traffic Class\" Group. Traffic class action enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. Traffic class action is disabled.\n"
	"\n"
	"\t1: Regular Class. Traffic class action is enabled and the CoS\n"
	"\t\tclassification traffic class is used.\n"
	"\n"
	"\t2: Alternative Class. Traffic class action is enabled and the class of\n"
	"\t\tthe 'nTrafficClassAlter' field is used.\n"
	"\n"
	"action.nTrafficClassAlternate :\n"
	"\tAlternative Traffic class\n"
	"\n"
	"action.eSnoopingTypeAction :\n"
	"\tAction \"IGMP Snooping\" Group. IGMP Snooping control and enable. Please\n"
	"\tnote that the 'nPortMapAction' configuration is ignored in case the\n"
	"\tIGMP snooping is enabled. Here, on read operations, 'nPortMapAction =\n"
	"\tGSW_PCE_ACTION_PORTMAP_DISABLE' is returned.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. IGMP Snooping is disabled.\n"
	"\n"
	"\t1: Default. Regular Packet. No IGMP Snooping action required.\n"
	"\n"
	"\t2: IGMP Report/Join Message.\n"
	"\n"
	"\t3: IGMP Leave Message.\n"
	"\n"
	"\t4: Router Solicitation/Advertisement message.\n"
	"\n"
	"\t5: IGMP Query Message.\n"
	"\n"
	"\t6: IGMP Group Specific Query Message.\n"
	"\n"
	"\t7: IGMP General Query message without Router Solicitation.\n"
	"\n"
	"action.eLearningAction :\n"
	"\tAction \"Learning\" Group. Learning action control and enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: MAC Address Learning action is disabled. MAC address learning is\n"
	"\t\tnot influenced by this rule.\n"
	"\n"
	"\t1: Learning is based on the forwarding decision. If the packet is\n"
	"\t\tdiscarded, the address is not learned. If the packet is forwarded\n"
	"\t\tto any egress port, the address is learned.\n"
	"\n"
	"\t2: Force No Learning. The address is not learned; forwarding decision\n"
	"\t\tignored.\n"
	"\n"
	"\t3: Force Learning. The address is learned, the forwarding decision\n"
	"\t\tignored. Note: The MAC Learning Control signals delivered to\n"
	"\t\tPort-Map filtering and combined with Final Forwarding Decision. The\n"
	"\t\tresult is used as a feedback for MAC Address learning in the\n"
	"\t\tBridging Table.\n"
	"\n"
	"action.eIrqAction :\n"
	"\tAction \"Interrupt\" Group. Interrupt action generate and enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. Interrupt Control Action is disabled for this rule.\n"
	"\n"
	"\t1: Regular Packet. The Interrupt Control Action is enabled, the packet\n"
	"\t\tis treated as a regular packet and no interrupt event is generated.\n"
	"\n"
	"\t2: Interrupt Event. The Interrupt Control Action is enabled and an\n"
	"\t\tinterrupt event is generated.\n"
	"\n"
	"action.eCrossStateAction :\n"
	"\tAction \"Cross State\" Group. Cross state action control and enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disable. The Cross State Action is disabled.\n"
	"\n"
	"\t1: Regular Packet. The Cross State Action is enabled and the packet is\n"
	"\t\ttreated as a non-Cross-State packet (regular packet). Therefore it\n"
	"\t\tdoes not ignore Port-State filtering rules.\n"
	"\n"
	"\t2: Cross-State packet. The Cross State Action is enabled and the\n"
	"\t\tpacket is treated as a Cross-State packet. It ignores the\n"
	"\t\tPort-State filtering rules.\n"
	"\n"
	"action.eCritFrameAction :\n"
	"\tAction \"Critical Frames\" Group. Critical Frame action control and\n"
	"\tenable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disable. The Critical Frame Action is disabled.\n"
	"\n"
	"\t1: Regular Packet. The Critical Frame Action is enabled and the packet\n"
	"\t\tis treated as a non-Critical Frame.\n"
	"\n"
	"\t2: Critical Packet. The Critical Frame Action is enabled and the\n"
	"\t\tpacket is treated as a Critical Frame.\n"
	"\n"
	"action.eTimestampAction :\n"
	"\tAction \"Timestamp\" Group. Time stamp action control and enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disable. Timestamp Action is disabled for this rule.\n"
	"\n"
	"\t1: Regular Packet. The Timestamp Action is enabled for this rule. The\n"
	"\t\tpacket is treated as a regular packet and no timing information is\n"
	"\t\tstored.\n"
	"\n"
	"\t2: Receive/Transmit Timing packet. Ingress and Egress Timestamps for\n"
	"\t\tthis packet should be stored.\n"
	"\n"
	"action.ePortMapAction :\n"
	"\tAction \"Forwarding\" Group. Port map action enable. This port\n"
	"\tforwarding configuration is ignored in case the action \"IGMP Snooping\"\n"
	"\tis enabled via the parameter 'nSnoopingTypeAction'.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disable. Forwarding Group Action is disabled.\n"
	"\n"
	"\t1: Regular Packet. Forwarding Action enabled. Select Default Port-Map\n"
	"\t\t(result of Default Forwarding Classification).\n"
	"\n"
	"\t2: Discard. Discard the packets.\n"
	"\n"
	"\t3: Forward to the CPU port. This requires that the CPU port is\n"
	"\t\tpreviously set by calling GSW_CPU_PORT_CFG_SET.\n"
	"\n"
	"\t4: Forward to a portmap, selected by the parameter 'nForwardPortMap'.\n"
	"\t\tPlease note that this feature is not supported by all hardware\n"
	"\t\tplatforms.\n"
	"\n"
	"\t5: The packet is treated as Multicast Router\n"
	"\t\tSolicitation/Advertisement or Query packet.\n"
	"\n"
	"\t6: The packet is interpreted as Multicast packet and learned in the\n"
	"\t\tmulticast group table.\n"
	"\n"

	"\t7: The CTAG VLAN portmap classification result is replaced by the \n"
	"\t\tportmap parameter 'nForwardPortMap'. All other classification\n"
	"\t\tresults stay unchanged and will be combined together with\n"
	"\t\tthe overwritten portmap.\n"
	"\n"
	"\t8: Add STAG VLAN portmap 'nForwardPortMap' to the overall portmap\n"
	"\t\tclassification result (AND'ed with the portmap).\n"
	"\n"
	"action.nForwardPortMap :\n"
	"\tTarget portmap for forwarded packets, only used if selected by\n"
	"\t'nPortMapAction'. Forwarding is done if 'nPortMapAction =\n"
	"\tGSW_PCE_ACTION_PORTMAP_ALTERNATIVE'. Every bit in the portmap\n"
	"\trepresents one port (port 0 = LSB bit).\n"
	"\n"

	"action.nForwardSubIfId :\n"
	"\tTarget Sub-Interface Id (GSWIP-3.0 only) for forwarded packets,\n"
	"\tonly used if selected by 'ePortMapAction'. Forwarding is done"
	"\tif 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'.\n"
	"\n"


	"action.bRemarkAction :\n"
	"\tAction \"Remarking\" Group. Remarking action enable\n"
	"\n"
	"action.bRemarkPCP :\n"
	"\tPCP remarking enable. Remarking enabling means that remarking is\n"
	"\tpossible in case the port configuration or metering enables remarking\n"
	"\ton that packet. Disabling remarking means that it is forced to not\n"
	"\tremarking this packet, independent of any port remarking of metering\n"
	"\tconfiguration.\n"
	"\n"

	"action.bRemarkSTAG_PCP :\n"
	"\tSTAG VLAN PCP remarking enable. Remarking enabling means that remarking is\n"
	"\tpossible in case the port configuration or metering enables remarking\n"
	"\ton that packet. Disabling remarking means that it is forced to not\n"
	"\tremarking this packet, independent of any port remarking of metering\n"
	"\tconfiguration.\n"
	"\n"
	"action.bRemarkSTAG_DEI :\n"
	"\tSTAG VLAN DEI remarking enable. Remarking enabling means that remarking is\n"
	"\tpossible in case the port configuration or metering enables remarking\n"
	"\ton that packet. Disabling remarking means that it is forced to not\n"
	"\tremarking this packet, independent of any port remarking of metering\n"
	"\tconfiguration.\n"
	"\n"

	"action.bRemarkDSCP :\n"
	"\tDSCP remarking enable Remarking enabling means that remarking is\n"
	"\tpossible in case the port configuration or metering enables remarking\n"
	"\ton that packet. Disabling remarking means that it is forced to not\n"
	"\tremarking this packet, independent of any port remarking of metering\n"
	"\tconfiguration.\n"
	"\n"
	"action.bRemarkClass :\n"
	"\tClass remarking enable Remarking enabling means that remarking is\n"
	"\tpossible in case the port configuration or metering enables remarking\n"
	"\ton that packet. Disabling remarking means that it is forced to not\n"
	"\tremarking this packet, independent of any port remarking of metering\n"
	"\tconfiguration.\n"
	"\n"
	"action.eMeterAction :\n"
	"\tAction \"Meter\" Group. Meter action control and enable. If metering\n"
	"\taction enabled, specified metering instance number overrules any other\n"
	"\tmetering assignment. Up to two metering instances can be applied to a\n"
	"\tsingle packet.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Action Disable.\n"
	"\n"
	"\t1: Action Enable. The action is enabled but no dedicated metering\n"
	"\t\tinstance is assigned by the rule.\n"
	"\n"
	"\t2: Action Enable. Assign one meter instance as given in parameter\n"
	"\t\t\"nMeterId\".\n"
	"\n"
	"\t3: Action Enable. Assign pair of meter instances. These instances are\n"
	"\t\t\"nMeterId\" and the next following meter instance index.\n"
	"\n"
	"action.nMeterId :\n"
	"\tMeter ID\n"
	"\n"
	"action.bRMON_Action :\n"
	"\tAction \"RMON\" Group. RMON action enable\n"
	"\n"
	"action.nRMON_Id :\n"
	"\tCounter ID (The index starts counting from zero).\n"
	"\n"
	"action.eVLAN_Action :\n"
	"\tAction \"CTAG VLAN\" Group. VLAN action enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. The VLAN Action is disabled.\n"
	"\n"
	"\t1: Regular VLAN. VLAN Action enabled. Select Default VLAN ID.\n"
	"\n"
	"\t2: Alternative VLAN. VLAN Action enabled. Select Alternative VLAN as\n"
	"\t\tconfigured in 'nVLAN_Id' or 'nSVLAN_Id'. For CTAG VLAN it requires that this \n"
	"\t\tVLAN ID is configured by calling GSW_VLAN_ID_CREATE in advance.\n"
	"\t\tThis additional call is not required for STAG VLAN.\n"
	"\n"
	"action.nVLAN_Id :\n"
	"\tAlternative VLAN Id\n"

	"\n"
	"action.eSVLAN_Action :\n"
	"\tAction \"STAG VLAN\" Group. VLAN action enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. The VLAN Action is disabled.\n"
	"\n"
	"\t1: Regular VLAN. VLAN Action enabled. Select Default VLAN ID.\n"
	"\n"
	"\t2: Alternative VLAN. VLAN Action enabled. Select Alternative VLAN as\n"
	"\t\tconfigured in 'nVLAN_Id' or 'nSVLAN_Id'. For CTAG VLAN it requires that this \n"
	"\t\tVLAN ID is configured by calling GSW_VLAN_ID_CREATE in advance.\n"
	"\t\tThis additional call is not required for STAG VLAN.\n"
	"\n"
	"action.nSVLAN_Id :\n"
	"\t Alternative STAG VLAN Id\n"
	"\n"
	"action.nFId :\n"
	"\tAlternative FID (not supported by all switches\n"

	"\n"
	"action.eVLAN_CrossAction :\n"
	"\tAction \"Cross VLAN\" Group. Cross VLAN action enable\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Disabled. The Cross VLAN Action is disabled.\n"
	"\n"
	"\t1: Regular VLAN Packet. Do not ignore VLAN filtering rules.\n"
	"\n"
	"\t2: Cross-VLAN packet. Ignore VLAN filtering rules.\n"
	"\n"

	"action.bCVLAN_Ignore_Control :\n"
	"\t0: Do not ignore CTAG VLAN classification.\n"
	"\n"
	"\t1:  Ignore CTAG VLAN classification.\n"
	"\n"

	"action.bPortBitMapMuxControl :\n"
	"\t0: port bitmap is used for alternative port map function.\n"
	"\n"
	"\t1:  port bitmap is used for STAG port member.\n"
	"\n"

	"action.bPortTrunkAction :\n"
	"\t0: action disable.\n"
	"\n"
	"\t1:  action enable.\n"
	"\n"

	"action.bPortLinkSelection :\n"
	"\t0: lower port selection.\n"
	"\n"
	"\t1: higher port selection.\n"
	"\n"

	"action.bFlowID_Action :\n"
	"\tAction \"Flow ID\". The Switch supports enhancing the egress packets by\n"
	"\ta device specific special tag header. This header contains detailed\n"
	"\tswitch classification results. One header file is a 'Flow ID', which\n"
	"\tcan be explicitly set as flow table action when hitting a table rule.\n"
	"\tIf selected, the Flow ID is given by the parameter 'nFlowID'.\n"
	"\n"
	"action.nFlowID :\n"
	"\tFlow ID"

	"action.bRoutExtId_Action :\n"
	"\tRouting Extension Id Selector - for GSWIP-3.0 only.\n"
	"\tWhen enabled, it expects a valid nRoutExtId value to be supplied.\n"
	"\tOnly entries matching with Routing Extension value in RT \n"
	"\tSession table will be subject to routing.\n"
	"\n"
	"action.nRoutExtId :\n"
	"\tRouting Extension Id Value - for GSWIP-3.0 only. (8-bits range).\n"
	"\n"
	"action.bRtDstPortMaskCmp_Action :\n"
	"\tRouting Destination Port Mask Comparison - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtSrcPortMaskCmp_Action :\n"
	"\tRouting Source Port Mask Comparison - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtDstIpMaskCmp_Action :\n"
	"\tRouting Destination IP Address Mask Comparison - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtSrcIpMaskCmp_Action :\n"
	"\tRouting Source IP Address Mask Comparison - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtInnerIPasKey_Action :\n"
	"\tSelector of IP in Tunneled IP header (Outer or Inner) - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtAccelEna_Action :\n"
	"\tRouting Acceleration Enable Action - for GSWIP-3.0 only.\n"
	"\n"
	"action.bRtCtrlEna_Action :\n"
	"\tRouting Control Enable Action - for GSWIP-3.0 only.\n"
	"\n"

	"action.eProcessPath_Action :\n"
	"\tAssignment of flow to Processing Path-1 or -2 - for GSWIP-3.0 only.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Processing Path is not enabled.\n"
	"\n"
	"\t1: Processing Path-1 is used for MPE-1.\n"
	"\n"
	"\t2: Processing Path-2 is used for MPE-2.\n"
	"\n"
	"\t3: Processing Path-1 and -2 are used for MPE-1 & MPE-2.\n"
	"\n"

	"action.bOamEnable :\n"
	"\tbOamEnable\n"
	"action.nRecordId :\n"
	"\tnRecordId\n"
	"action.bExtractEnable :\n"
	"\tbExtractEnable\n"
	"action.eColorFrameAction :\n"
	"\teColorFrameAction\n"
	"action.bExtendedVlanEnable :\n"
	"\tbExtendedVlanEnable\n"
	"action.nExtendedVlanBlockId :\n"
	"\tnExtendedVlanBlockId\n"
	"\n"

	"action.ePortFilterType_Action :\n"
	"\tPort Filter Action Config for this flow - for GSWIP-3.0 only.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Port Filter Action is Unused.\n"
	"\n"
	"\t1: Port Filter Action Type-1 is used.\n"
	"\n"
	"\t2: Port Filter Action Type-2 is used.\n"
	"\n"
	"\t3: Port Filter Action Type-3 is used.\n"
	"\n"
	"\t4: Port Filter Action Type-4 is used.\n"
	"\n"
	"\t5: Port Filter Action Type-5 (Unknown Unicast) is used.\n"
	"\n"
	"\t6: Port Filter Action Type-6 (Unknown Multicast) is used.\n"
	"\n"
	"\n",
	/* 108: GSW_REGISTER_GET */
	"Read an internal register. The register offset defines which register to\n"
	"access in which table. This routine only accesses the M4599_PDI and the\n"
	"ETHSW_PDI of the switch. All PHY registers are accessed via\n"
	"GSW_MDIO_DATA_WRITE and GSW_MDIO_DATA_READ. Note that the switch\n"
	"API implementation checks whether the given address is inside the valid\n"
	"address range. It returns with an error in case an invalid address is given.\n"
	"\nParameter:\n----------\n"
	"nRegAddr :\n"
	"\tRegister Address Offset for read or write access."
	"\n",
	/* 109: GSW_REGISTER_SET */
	"Write to an internal register. All PHY registers are accessed via\n"
	"GSW_MDIO_DATA_WRITE and GSW_MDIO_DATA_READ. Note that the switch\n"
	"API implementation checks whether the given address is inside the valid\n"
	"address range. It returns with an error in case an invalid address is given.\n"
	"\nParameter:\n----------\n"
	"nRegAddr :\n"
	"\tRegister Address Offset for read or write access.\n"
	"nData :\n"
	"\tValue to write to or read from 'nRegAddr'.\n"
	"nClearBits :\n"
	"\tBitmask to clear dedicated databits before writing back the data.\n"
	"\tThe field 'nData' is ignored in case 'nCleartBits' is given\n"
	"\tdata = data & ~nCleartBits\n"
	"nSetBits :\n"
	"\tBitmask to set dedicated data bits before writing back the data.\n"
	"\tThe field 'nData' is ignored in case 'nSetBits' is given.\n"
	"\t'nClearBits' is applied before 'nSetBits'.\n"
	"\tdata = data | nSetBits"
	"\n",
	/* 110: GSW_RESET */
	"Forces a hardware reset of the switch device or switch macro. The device\n"
	"automatically comes back out of reset and contains the initial values. All\n"
	"previous configurations are lost.\n"
	"\nParameter:\n----------\n"
	"eReset :\n"
	"\tReset selection.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Switch Macro reset\n"
	"\n"
	"\t1: MDIO master interface reset",
	/* 111: GSW_RMON_EXTEND_GET */
	"Read out additional traffic flow (RMON) counters. The zero-based 'nPortId'\n"
	"structure element describes the physical switch port for the requested\n"
	"statistic information.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.",
	/* 112: GSW_TIMESTAMP_TIMER_GET */
	"This command reads out the switch global reference timer counter that is\n"
	"used by the packet timestamp capture when sending and receiving Ethernet port level.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nSec :\n"
	"\tSecond. Absolute second timer count\n"
	"nNanoSec :\n"
	"\t Nano Second. Absolute nano second timer count.\n"
	"nFractionalNanoSec :\n"
	"\t Fractional Nano Second. Absolute fractional nano second timer count. \n",
	/* 113: GSW_TIMESTAMP_TIMER_SET */
	"This command sets the packet timestamp reference counter.\n"
	"This reference timer is a switch global timer which is used by the\n"
	"packet timestamp capture when sending and receiving Ethernet port level\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nSec :\n"
	"\tSecond. Absolute second timer count\n"
	"nNanoSec :\n"
	"\t Nano Second. Absolute nano second timer count.\n"
	"nFractionalNanoSec :\n"
	"\t Fractional Nano Second. Absolute fractional nano second timer count. \n",
	/* 114: GSW_TIMESTAMP_PORT_READ */
	"This command reads out the port related time stamp values. This time stamp is captured\n"
	"for ingress and egress packets triggered due to a traffic flow table time stamp action.\n"
	"A port related packet timestamp is triggered by the flow table action 'eTimestampAction'.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n",
	/* 115: GSW_TRUNKING_CFG_GET */
	"Read out the current port trunking algorithm that is used to retrieved if a packet is \n"
	"sent on the lower or higher trunking port index number.The algorithm  performs an hash \n"
	"calculation over the MAC- and IP- addresses using the source- and destination- fields.\n"
	"This command retrieve which of the mentioned fields is used by the hash algorithm.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"bIP_Src :\n"
	"\tIP source address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"bIP_Dst :\n"
	"\tIP destination address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"bMAC_Src :\n"
	"\tMAC source address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"bMAC_Dst :\n"
	"\tMAC destination address is used by the hash algorithm to calculate the egress trunking port index.\n",
	/* 116: GSW_TRUNKING_CFG_SET */
	"Configure the current port trunking algorithm that is used to retrieved if a packet is \n"
	"sent on the lower or higher trunking port index number. The algorithm performs an hash \n"
	"calculation over the MAC- and IP- addresses using the source- and destination- fields.\n"
	"This command retrieve which of the mentioned fields is used by the hash algorithm.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"bIP_Dst :\n"
	"\tIP destination address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Enabled, Destination IP address is used for distrubution algorithm.\n"
	"\n"
	"\t1: Disable, Destination IP address is not used for distrubution algorithm\n"
	"\n"
	"bIP_Src :\n"
	"\tIP source address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Enabled, Source IP address is used for distrubution algorithm.\n"
	"\n"
	"\t1: Disable, Source IP address is not used for distrubution algorithm\n"
	"\n"
	"bMAC_Dst :\n"
	"\tMAC destination address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Enabled, Destination MAC address is used for distrubution algorithm.\n"
	"\n"
	"\t1: Disable, Destination MAC address is not used for distrubution algorithm\n"
	"\n"
	"bMAC_Src :\n"
	"\tMAC source address is used by the hash algorithm to calculate the egress trunking port index.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Enabled, Source MAC address is used for distrubution algorithm.\n"
	"\n"
	"\t1: Disable, Source MAC address is not used for distrubution algorithm\n"
	"\n",
	/* 117: GSW_TRUNKING_PORT_CFG_GET */
	"Read out the port trunking state of a given physical Ethernet switch port 'nPortId'.\n"
	"Switch API sets the boolean flag 'bAggregateEnable' and the aggregated trunking \n"
	"port 'nAggrPortId' in case trunking is enabled on the port.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n",
	/* 118: GSW_TRUNKING_PORT_CFG_SET */
	"Configure the port trunking on two physical Ethernet switch ports.\n"
	"A new port trunking group of two groups could be placed or removed.\n"
	"The two port index number are given with the parameter 'nPortId' and 'nAggrPortId'.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"bAggregateEnable :\n"
	"\tPorts are aggregated. Enabling means that the 'nPortId' and the 'nAggrPortId' \n"
	"\tports form an aggregated link. \n"
	"nAggrPortId :\n"
	"\tSecond Aggregated Ethernet Port number (zero-based counting).\n"
	"\tThe valid range is hardware dependent.An error code is delivered if the selected \n"
	"\tport is not available.\n",
	/* 119: GSW_QOS_WRED_PORT_CFG_GET */
	"Read out the WRED drop thresholds for a dedicated egress port.Given parameters \n"
	"are rounded to the segment size of the HW platform. The supported segment size \n"
	"is given by the capability list by using GSW_CAP_GET.\n"
	"The configuration can be changed by using GSW_QOS_WRED_PORT_CFG_SET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n",
	/* 120: GSW_QOS_WRED_PORT_CFG_SET */
	"Configures the WRED drop thresholds for a dedicated egress port. Given parameters\n"
	"are rounded to the segment size of the HW platform. The supported segment size is \n"
	"given by the capability list by using GSW_CAP_GET.\n"
	"The command GSW_QOS_WRED_PORT_CFG_GET retrieves the current configuration.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"nRed_Min :\n"
	"\tWRED Red Threshold Min [number of segments].\n"
	"\n"
	"nRed_Max :\n"
	"\tWRED Red Threshold Max [number of segments].\n"
	"\n"
	"nYellow_Min :\n"
	"\tWRED Yellow Threshold Min [number of segments].\n"
	"\n"
	"nYellow_Max :\n"
	"\tWRED Yellow Threshold Max [number of segments].\n"
	"\n"
	"nGreen_Min :\n"
	"\tWRED Green Threshold Min [number of segments].\n"
	"\n"
	"nGreen_Max :\n"
	"\tWRED Green Threshold Max [number of segments].\n",
	/* 121: GSW_QOS_FLOWCTRL_CFG_GET */
	"Read out the global flow control thresholds for conforming and non-conforming packets.\n"
	"The configured thresholds apply to the global switch segment buffer.\n"
	"The configuration can be changed by GSW_QOS_FLOWCTRL_CFG_SET.\n"
	"Given parameters are rounded to the segment size of the HW platform. The supported\n"
	"segment size is given by the capability list by using GSW_CAP_GET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n",
	/* 122: GSW_QOS_FLOWCTRL_CFG_SET */
	"Configures the global flow control thresholds for conforming and non-conforming packets.\n"
	"The configured thresholds apply to the global switch segment buffer.\n"
	"The current configuration can be retrieved by \ref GSW_QOS_FLOWCTRL_CFG_GET.\n"
	"Given parameters are rounded to the segment size of the HW platform. The supported \n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nFlowCtrlNonConform_Min :\n"
	"\tGlobal Buffer Non Conforming Flow Control Threshold Minimum [number of segments].\n"
	"\n"
	"nFlowCtrlNonConform_Max :\n"
	"\tGlobal Buffer Non Conforming Flow Control Threshold Maximum [number of segments].\n"
	"\n"
	"nFlowCtrlConform_Min :\n"
	"\tGlobal Buffer Conforming Flow Control Threshold Minimum [number of segments].\n"
	"\n"
	"nFlowCtrlConform_Max :\n"
	"\tGlobal Buffer Conforming Flow Control Threshold Maximum [number of segments].\n",
	/* 123: GSW_QOS_FLOWCTRL_PORT_CFG_GET */
	"Read out the ingress port flow control thresholds for occupied buffer segments. \n"
	"The configuration can be changed by \ref GSW_QOS_FLOWCTRL_PORT_CFG_SET.\n"
	"Given parameters are rounded to the segment size of the HW platform. The supported \n"
	"segment size is given by the capability list by using  GSW_CAP_GET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n",
	/* 124: GSW_QOS_FLOWCTRL_PORT_CFG_SET */
	"Configures the ingress port flow control thresholds for occupied buffer segments.\n"
	"The current configuration can be retrieved by GSW_QOS_FLOWCTRL_PORT_CFG_GET.\n"
	"Given parameters are rounded to the segment size of the HW platform. The supported\n"
	"segment size is given by the capability list by using GSW_CAP_GET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"nFlowCtrl_Min :\n"
	"\tIngress Port occupied Buffer Flow Control Threshold Minimum [number of segments].\n"
	"nFlowCtrl_Max :\n"
	"\tIngress Port occupied Buffer Flow Control Threshold Maximum [number of segments].\n",
	/* 125: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET */
	"Read out the egress queue specific buffer reservation.\n"
	"Configuration can be read by  GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).\n",
	/* 126: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET */
	"Configure the egress queue buffer reservation. WRED GREEN packets are never\n"
	"dropped by any WRED algorithm (queue,port or global buffer level) in case \n"
	"they are below this reservation threshold.The amount of reserved segments \n"
	"cannot be occupied by other queues of the switch. The egress queue related \n"
	"configuration can be retrieved by calling  GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET.\n"
	"Note: Supported for GSWIP 2.2 and newer and returns with an error for older hardware revisions.\n"
	"\nParameter:\n----------\n"
	"nQueueId :\n"
	"\tQoS queue index (zero-based counting).\n"
	"nBufferReserved :\n"
	"\tReserved Buffer Segment Threshold [number of segments].\n",

	/* 127: GSW_SVLAN_CFG_GET */
	"Get The current STAG VLAN global device configuration.\n",
	/* 128: GSW_SVLAN_CFG_SET */
	"Set STAG VLAN global device configuration.\n"
	"\nParameter:\n----------\n"
	"nEthertype :\n"
	"\tSVLAN ID. Protocl EtherType Field. This 16-bit of the STAG VLAN. \n",
	/* 129: GSW_SVLAN_PORT_CFG_GET */
	"Get STAG VLAN Port Configuration. This function returns the STAG VLAN configuration of\n"
	"the given Port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available. \n",
	/* 130: GSW_SVLAN_PORT_CFG_SET */
	"Set STAG VLAN Port Configuration. This function sets the STAG VLAN configuration of the\n"
	"given Port 'nPortId'.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is\n"
	"\tnot available.\n"
	"\n"
	"bSVLAN_TagSupport :\n"
	"\tPort based STAG VLAN Support. All STAG VLAN protocol parsing and configuration features\n"
	"\tare only applied on this port in case the STAG VLAN port support is enabled.\n"
	"\n"
	"bSVLAN_MACbasedTag :\n"
	"\tPort Egress MAC based STAG VLAN. All egress packets contain a STAG VLAN ID \n"
	"\that is based on the VLAN ID which is retrieved from the MAC bridging table.\n"
	"\tThis MAC bridging table SVLAN ID can be learned from the snooped traffic or statically added.\n"
	"\n"
	"nPortVId :\n"
	"\tPort STAG VLAN ID (PVID). The software shall ensure that the used VLAN has\n"
	"\tbeen configured in advance on the hardware by using\n"
	"\tGSW_VLAN_ID_CREATE.\n"
	"\n"
	"bVLAN_ReAssign :\n"
	"\tReassign all ingress STAG VLAN tagged packets to the port-based STAG VLAN ID (PVID)\n"
	"\n"
	"eVLAN_MemberViolation :\n"
	"\tVLAN ingress and egress membership violation mode. Allows admittance\n"
	"\tof STAG VLAN-tagged packets where the port is not a member of the STAG VLAN ID\n"
	"\tcarried in the received and sent packet.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: No VLAN member violation. Ingress and egress packets violating the\n"
	"\t\tmembership pass and are not filtered out.\n"
	"\n"
	"\t1: VLAN member violation for ingress packets. Ingress packets\n"
	"\t\tviolating the membership are filtered out. Egress packets violating\n"
	"\t\tthe membership are not filtered out.\n"
	"\n"
	"\t2: VLAN member violation for egress packets. Egress packets violating\n"
	"\t\tthe membership are filtered out. Ingress packets violating the\n"
	"\t\tmembership are not filtered out.\n"
	"\n"
	"\t3: VLAN member violation for ingress and egress packets. Ingress and\n"
	"\t\tegress packets violating the membership are filtered out.\n"
	"\n"
	"eAdmitMode :\n"
	"\tIngress STAG VLAN-tagged or untagged packet filter configuration.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Admit all. Tagged and untagged packets are allowed.\n"
	"\n"
	"\t1: Untagged packets only (not supported yet). Tagged packets are\n"
	"\t\tdropped.\n"
	"\n"
	"\t2: Tagged packets only. Untagged packets are dropped.\n",
	/* 131: GSW_QOS_SVLAN_CLASS_PCP_PORT_GET */
	"Read out the current egress port related traffic class to 802.1P (PCP) priority mapping table.\n"
	"One table is given for each egress port.\n"
	"Priority map entry index value is calculated by 'index=PCP + 8*DEI'\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is not available. \n",
	/* 132: GSW_QOS_SVLAN_CLASS_PCP_PORT_SET */
	"Configure the egress port related traffic class to STAG VLAN 802.1P (PCP) priority mapping table.\n"
	"One table is given for each egress port.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEthernet Port number (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port isnot available.\n"
	"nTrafficClass :\n"
	"\t\tTraffic class associated with a particular CPCP, SPCp and DSCP values.\n"
	"\t\t The index starts counting from zero. \n"
	"nCPCP:\n"
	"\tConfigures the traffic class to CPCP (3-bit) mapping.The queue index starts counting from zero.\n"
	"\tTraffic class associated with a particular 802.1P (PCP) priority mapping value.\n"
	"\tOne table is given per egress port. Priority map entry structure.\n"
	"\tThe lowest 3 LSB bits (0 ... 2) of 'nPCP_DEI' describe the PCP field.\n"
	"\tBit 3 describes the 'DEI' field. \n"
	"nSPCP:\n"
	"\tConfigures the traffic class to CPCP (3-bit) mapping.The queue index starts counting from zero.\n"
	"\tTraffic class associated with a particular 802.1P (PCP) priority mapping value.\n"
	"\tOne table is given per egress port. Priority map entry structure.\n"
	"\tThe lowest 3 LSB bits (0 ... 2) of 'nPCP_DEI' describe the PCP field.\n"
	"\tBit 3 describes the 'DEI' field. \n"
	"nDSCP:\n"
	"\tConfigures the traffic class to CPCP (3-bit) mapping.The queue index starts counting from zero.\n"
	"\tTraffic class associated with a particular 802.1P (PCP) priority mapping value.\n"
	"\tOne table is given per egress port. Priority map entry structure.\n"
	"\tThe lowest 3 LSB bits (0 ... 2) of 'nPCP_DEI' describe the PCP field.\n"
	"\tBit 3 describes the 'DEI' field. \n",
	/* 133: GSW_QOS_SVLAN_PCP_CLASS_GET */
	"Read out the 802.1P (PCP) to traffic class mapping table.\n"
	"This configuration applies to the entire switch device.\n"
	"Priority map entry index value is calculated by 'index=PCP + 8*DEI'. \n",
	/* 134: GSW_QOS_SVLAN_PCP_CLASS_SET */
	"Configure the traffic class to 802.1P (PCP) priority mapping table. \n"
	"This table is global for the entire switch device. \n"
	"\nParameter:\n----------\n"
	"nPCP :\n"
	"\t\tTable index of the PCP to traffic table mappingtable. The index starts counting from zero. \n"
	"nTrafficClass :\n"
	"\t\tTraffic class associated with a particular STAG VLAN 802.1P (PCP) priority and \n"
	"\t\tDrop Eligiable Indicator (DEI) mapping value. \n"
	"\t\tPriority map entry index value is calculated by 'index=PCP + 8*DEI'\n"
	"\t\tThe index starts counting from zero.\n"
	"nTrafficColor :\n"
	"\t\tTraffic Color associated with a particular STAG VLAN 802.1P (PCP) priority and. \n"
	"\t\tDrop Eligiable Indicator (DEI) mapping value. \n"
	"nPCP_Remark_Enable :\n"
	"\tPCP Remark disable control.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  PCP remarking enabled for this code point.\n"
	"\n"
	"\t1:  PCP remarking disabled for this code point.\n"
	"\n"
	"nDEI_Remark_Enable :\n"
	"\tDEI Remark disable control.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:   DEI remarking enabled for this code point.\n"
	"\n"
	"\t1:   DEI remarking disabled for this code point.\n"
	"\n",
	/* 135: GSW_PCE_EG_VLAN_CFG_SET */
	"Configure the Egress VLAN Treatment settings of PCE for given egress Port.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEgress Port Identifier (zero-based counting). The valid range is\n"
	"\thardware dependent. \n"
	"bEgVidEna :\n"
	"\tEnable or disable Egress VLAN treatment on given port.\n"
	"eEgVLANmode :\n"
	"\tEgress VLAN Treatment Selector - FID or SubIf-GroupId based.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: FID based Egress VLAN Treatment.\n"
	"\n"
	"\t1: Sub-InterfaceId Group (Bits 12 to 8) based Egress VLAN Treatment.\n"
	"nEgStartVLANIdx :\n"
	"\tEgress VLAN Treatment start index for specified nPortId. Continuous block \n"
	"\t of VLAN is used until next port's Start block assignment\n"
	"\n",
	/* 136: GSW_PCE_EG_VLAN_CFG_GET */
	"Read the Egress VLAN Treatment settings of PCE for given egress Port.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEgress Port Identifier (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is not available. \n"
	"\n",
	/* 137: GSW_PCE_EG_VLAN_ENTRY_WRITE */
	"Configure the Egress VLAN Treatment settings of PCE for given egress Port.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"\tEgress Port Identifier (zero-based counting). The valid range is\n"
	"\thardware dependent. An error code is delivered if the selected port is not available. \n"
	"nIndex :\n"
	"\tIndex corresponding to FID or SubIf-ID Group\n"
	"bEgVLAN_Action :\n"
	"\tEnable or disable Egress VLAN Treatment Action.\n"
	"bEgSVidRem_Action :\n"
	"\tEnable or disable the STAG VLAN Removal action.\n"
	"bEgSVidIns_Action :\n"
	"\tEnable or disable the STAG VLAN Insert action.\n"
	"nEgSVid :\n"
	"\tSVLAN Value to be inserted in egress.\n"
	"bEgCVidRem_Action :\n"
	"\tEnable or disable the CTAG VLAN Removal action.\n"
	"bEgCVidIns_Action :\n"
	"\tEnable or disable the CTAG VLAN Insert action.\n"
	"nEgCVid :\n"
	"\tCVLAN Value to be inserted in egress.\n"
	"\n",
	/* 138: GSW_PCE_EG_VLAN_ENTRY_READ */
	"Read the Egress VLAN Treatment settings of PCE for given egress Port.\n"
	"\nParameter:\n----------\n"
	"nIndex :\n"
	"\tIndex corresponding to FID or SubIf-ID Group\n"
	"\n",
	/* 139: GSW_PMAC_BM_CFG_GET */
	"Read the backpressure mapping table between Tx Queues for Egress and Rx Queues \n"
	"for Ingress congestion on given DMA channel. \n"
	"\nParameter:\n----------\n"
	"nTxDmaChanId :\n"
	"\tTx DMA Channel Identifier (0..15). \n"
	"\n",
	/* 140: GSW_PMAC_EG_CFG_GET */
	"Read egress attributes config on given PMAC port. \n"
	"\nParameter:\n----------\n"
	"nDestPortId :\n"
	"\tDestination Port Identifier (0..15) - Part of Table Index (Bits 0-3).\n"
	"bProcFlagsSelect :\n"
	"\tSelector for Processing Flags (MPE1, MPE2, DEC & ENC bits). If disabled, \n"
	"\tthen the combination of flags bDecFlag, bEncFlag, bMpe1Flag and  bMpe2Flag\n"
	"\t are considered as index instead of nTrafficClass. For using these \n"
	"\tcombination flags, turn ON this boolean selector.\n"
	"\tTC or combination processing flag is decided at global \n"
	"\tlevel through bProcFlagsEgPMACEna.\n"
	"\tIt is expected that user always passes correct value based \n"
	"\tupon bProcFlagsEgMPACEna. If mismatch found with global PMAC mode,\n"
	"\t SWAPI will return error code.\n"
	"nTrafficClass :\n"
	"\tTraffic Class value [Lower 4 -bits (LSB-0, 1, 2, 3)].- Part of Table Index Bits 4-7.\n"
	"\tThis value is considered, only when bProcFlagsSelect is not set.\n"
	"nFlowIDMsb :\n"
	"\tFlow-ID MSB (2-bits) value -  valid range (0..2). - Part of Table Index Bits 8-9.\n"
	"bMpe1Flag :\n"
	"\tMPE-1 Flag value - Part of Table Index Bit 4. Valid only when bProcFlagsSelect is set\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  MPE-1 Marked Flag disabled.\n"
	"\n"
	"\t1:  MPE-1 Marked Flag Enabled.\n"
	"bMpe2Flag :\n"
	"\tMPE-2 Flag value - Part of Table Index Bit 5. Valid only when bProcFlagsSelect is set.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  MPE-2 Marked Flag disabled.\n"
	"\n"
	"\t1:  MPE-2 Marked Flag Enabled.\n"
	"bEncFlag :\n"
	"\tCryptography Encryption Action Flag value - Part of Table Index Bit 7.\n"
	"\t Valid only, when bProcFlagsSelect is set\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Cryptography Encryption Action Flag disabled.\n"
	"\n"
	"\t1:  Cryptography Encryption Action Flag Enabled.\n"
	"bDecFlag :\n"
	"\tCryptography Decryption Action Flag value - Part of Table Index Bit 6.\n"
	"\t Valid only, when bProcFlagsSelect is set.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Cryptography Decryption Action Flag disabled.\n"
	"\n"
	"\t1:  Cryptography Decryption Action Flag Enabled.\n"
	"\n",
	/* 141: GSW_PMAC_IG_CFG_GET */
	"Reads the PMAC Ingress  config on given DMA channel. \n"
	"\nParameter:\n----------\n"
	"nTxDmaChanId :\n"
	"\tTx DMA Channel Identifier (0..15). \n"
	"\n",
	/* 142: GSW_PMAC_COUNT_GET */
	"Reads the  Counters for given DMA Channel/ given source Port ID. \n"
	"\nParameter:\n----------\n"
	"nTxDmaChanId :\n"
	"\tTransmit DMA Channel/ Source Port ID Identifier (0..15). \n"
	"\n",
	/* 143: GSW_RMON_MODE_SET */
	"Configures a Traffic Statistic Counter (RMON counter). \n"
	"Set RMON counting mode to bytes or Packet based. \n"
	"\nParameter:\n----------\n"
	"eRmonType :\n"
	"\tSelect RMON Counters Type. \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: All RMON Types Counters (GSW_RMON_ALL_TYPE). \n"
	"\n"
	"\t1: All PMAC RMON Counters (GSW_RMON_PMAC_TYPE).\n"
	"\n"
	"\t2: Port based RMON Counters (GSW_RMON_PORT_TYPE).\n"
	"\n"
	"\t3: Meter based RMON Counters (GSW_RMON_METER_TYPE).\n"
	"\n"
	"\t4: Interface based RMON Counters(GSW_RMON_IF_TYPE).\n"
	"\n"
	"\t5: Route based RMON Counters (GSW_RMON_ROUTE_TYPE).\n"
	"\n"
	"\t6: Redirected Traffic based RMON Counters (GSW_RMON_REDIRECT_TYPE).\n"
	"\n"
	"eCountMode :\n"
	"\tSelect RMON Counters Mode. \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Packet based RMON Counters(GSW_RMON_COUNT_PKTS). \n"
	"\n"
	"\t1: Bytes based RMON Counters (GSW_RMON_COUNT_BYTES).\n"
	"\n"
	"\t2: Number of dropped frames, supported only for interface cunters (GSW_RMON_DROP_COUNT).\n"
	"\n",
	/* 144: GSW_RMON_IF_GET */
	"Get the Interface RMON Counters . \n"
	"\nParameter:\n----------\n"
	"nIfId :\n"
	"\tInterface Counter Index Number. (Range : 0-255). \n"
	"\n",
	/* 145: GSW_RMON_REDIRECT_GET */
	"Get the Redirected RMON Counters. \n"
	"\n",
	/* 114: GSW_RMON_ROUTE_GET */
	"Get the Routing RMON Counters. \n"
	"\nParameter:\n----------\n"
	"nRoutedPortId :\n"
	"\tRouted Port Number. \n"
	"\n",
	/* 147: GSW_RMON_METER_GET */
	"Get the Meter Instance statistic counter. \n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter Instance number (zero-based counting). \n"
	"\n",
	/* 148: GSW_QOS_METER_ACT */
	"Triggers Metering Action for Traffic by CPU/MPE. \n"
	"Control Action for triggering metering action from \n"
	"CPU users [(CPU or MPE) or (CPU-1 & CPU-2) ] and This control trigger \n"
	"action performs metering and returns output color.\n"
	"\nParameter:\n----------\n"
	"nCpuUserId :\n"
	"\tCPU User Id . \n"
	"nMeterId :\n"
	"\tPrimary Meter Instance Id (zero-based counting). \n"
	"bMeterEna :\n"
	"\tPrimary Meter Enable or Disable Action. \n"
	"nSecMeterId :\n"
	"\tSecondary Meter Instance Id (zero-based counting). \n"
	"bSecMeterEna :\n"
	"\tSecondary Meter Enable or Disable Action. \n"
	"ePreColor :\n"
	"\tPre-Color to indicate the traffic type getting Metered.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Critical Packet. Metering never changes the drop precedence \n"
	"\t\tof these packets (GSW_DROP_PRECEDENCE_CRITICAL). \n"
	"\t1: Green Drop Precedence Packet. Packet is marked with a 'low' \n"
	"\t\tdrop precedence (GSW_DROP_PRECEDENCE_GREEN).\n"
	"\t2: Yellow Drop Precedence Packet. Packet is marked with a 'middle' \n"
	"\t\tdrop precedence (GSW_DROP_PRECEDENCE_YELLOW). \n"
	"\t3: Red Drop Precedence Packet. Packet is marked with a 'high' \n"
	"\t\tdrop precedence. (GSW_DROP_PRECEDENCE_RED).\n"
	"\n"
	"pktLen :\n"
	"\tPacket Length in Bytes subject to Metering action from CPU. \n"
	"\n",


	/* 149: GSW_PMAC_GLBL_CFG_SET */
	"Writes the global PMAC settings applicable to PMAC ports \n"
	"It is used to configure the global settings such as Padding, \n"
	" Checksum, Length and Egress PMAC Selector fields. \n"
	"\nParameter:\n----------\n"
	"bAPadEna :\n"
	"\tAutomatic Padding Settings - Disabled (Default), to enable set it true. \n"
	"bPadEna :\n"
	"\tGlobal Padding Settings - Disabled (Default), to enable set it true. \n"
	"bVPadEna :\n"
	"\tVLAN Padding Setting - Disabled (Default), to enable set it true \n"
	"\t applicable when bPadEna is set. \n"
	"bSVPadEna :\n"
	"\tStacked VLAN Padding Setting - Disabled (Default), to enable set \n"
	"\t it true - applicable when bPadEna is set. \n"
	"bTxFCSDis :\n"
	"\tTransmit FCS Regeneration Setting - Enabled (Default), \n"
	"\t\tto disable set it true. \n"
	"bIPTransChkRegDis :\n"
	"\tIP and Transport (TCP/UDP) Headers Checksum Generation \n"
	"\t Control - Enabled (Default), to disable set it true. \n"
	"bIPTransChkVerDis :\n"
	"\tIP and Transport (TCP/UDP) Headers Checksum Verification \n"
	"\tControl - Enabled (Default), to disable set it true. \n"
	"bJumboEna :\n"
	"\tTo enable receipt of Jumbo frames - Disabled \n"
	"\t(Default - 1518 bytes normal frames without VLAN tags), \n"
	"\tto enable Jumbo set it truee. \n"
	"nMaxJumboLen :\n"
	"\tMaximum length of Jumbo frames in terms of bytes \n"
	"\t(Bits 13:0). The maximum handled in Switch is 9990 bytes.\n"
	"nJumboThreshLen :\n"
	"\tThreshold length for Jumbo frames qualification in terms \n"
	"\t\tof bytes (Bits 13:0).\n"
	"bLongFrmChkDis :\n"
	"\tLong frame length check-Enabled(Default),to disable set it true.\n"

	"eShortFrmChkType :\n"
	"\tShort frame length check Type - default (Enabled for \n"
	"\t 64 bytes without considering VLAN.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Short frame length check is disabled. \n"
	"\t1: Short frame length check is enabled without considering VLAN Tags.\n"
	"\t2: Short frame length check is enabled including VLAN Tags. \n"
	"\t3: Reserved - Currently unused. \n"
	"\n"
	"bProcFlagsEgCfgEna :\n"
	"\tEgress PMAC Config Table Selector - TrafficClass or Processing \n"
	"\tFlags (MPE1, MPE22, DEC, ENC based).\n"
	"\tThe default setting is Traffic Class based selector for Egress PMAC. \n"
	"\n",
	/* 150: GSW_PMAC_GLBL_CFG_GET */
	"Get the global PMAC settings currently configured on PMAC port\n"
	"\n",


#if defined(CONFIG_LTQ_TEST) && CONFIG_LTQ_TEST

	/* 152: GSW_ROUTE_ENTRY_READ */
	"This command reads a Routing session config (pattern and action info)\n"
	"for the given index. A routing session (pattern and action) can be added\n"
	"using the command \ref GSW_ROUTE_ENTRY_ADD.\n"
	"Parameter:\n----------\n"
	"nRtIndex :\n"
	"\tRouting Session Entry Index Value - returned in GSW_ROUTE_ENTRY_ADD operation"
	"\n",

	/* 153: GSW_ROUTE_ENTRY_DELETE */
	"This command deletes an earlier added routing session of specified index\n"
	"and pattern. It is must specify the index returned during creation.\n"
	" The pattern part is only used for compairng with the pattern stored in index.\n"
	"A routing rule and action of specified index can be read using \n"
	"the command \ref GSW_ROUTE_ENTRY_READ. \n"
	"\nParameter:\n----------\n"
	"nRtIndex :\n"
	"\tRouting Session Entry Index Value - returned in GSW_ROUTE_ENTRY_ADD operation"
	"\n",

	/* 154: GSW_ROUTE_ENTRY_ADD */
	"This command adds a routing session of specified pattern and action.\n"
	"The pattern part describes the parameters to identify an incoming packet session\n"
	"to which the dedicated actions should be applied.Packets having the same pattern  \n"
	"field belongs to same session and applied to same action.\n"
	"A routing rule and action can be read using the command \ref GSW_ROUTE_ENTRY_READ.\n"
	"Routing Pattern Part.\n"
	"\nParameter:\n----------\n"
	"nHashVal :\n"
	"\tRouting Session Entry Hash Value.\n"
	"\n"
	"nRtIndex :\n"
	"\tRouting Session Entry Index Value\n"
	"\n"
	"bPrio :\n"
	"\tIndicate it is a priority session.\n"
	"\n"
	"nFlags :\n"
	"\tFlags to indicate special status E.g. - Swap done (1), Free (2),...\n"
	"\n"
	"routeEntry.pattern.eIpType :\n"
	"\tThe session source/destination IPv4/v6 address seletion.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Routing Pattern for IP selection disabled.\n"
	"\n"
	"\t1: Routing Pattern for IPv4.\n"
	"\n"
	"\t2: Routing Pattern for IPv6.\n"
	"\n"
	"routeEntry.pattern.nSrcIP :\n"
	"\tThe session source IPv4/v6 address used for hash computation. \n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"routeEntry.pattern.nDstIP :\n"
	"\tThe session destination IPv4/v6 address for hash computation.\n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"
	"routeEntry.pattern.nSrcPort :\n"
	"\tTCP/UDP source port information\n"
	"\n"
	"routeEntry.pattern.nDstPort :\n"
	"\tTCP/UDP destination port information\n"
	"\n"
	"routeEntry.pattern.nRoutExtId :\n"
	"\tRouting extension Id from Flow Table action.\n"
	"\n"
	"routeEntry.pattern.bValid :\n"
	"\tIndicate, if a particular routing entry is valid or not\n"
	"\n"

	"Routing Action Part.\n\n"

	"routeEntry.action.nDstPortMap :\n"
	"\tSession destination port map. LSB refers to Port 0.\n"
	"\n"
	"routeEntry.action.nDstSubIfId :\n"
	"\tSession destination sub-interace Id. \n"
	"\n"

	"routeEntry.action.eIpType :\n"
	"\tSession new IP address type, IPv4/v6, address seletion.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: Action for IP selection disabled.\n"
	"\n"
	"\t1: Routing action for IPv4.\n"
	"\n"
	"\t2: Routing action for IPv6.\n"
	"\n"
	"routeEntry.action.nNATIPaddr :\n"
	"\tSession new IP address after NAT for eIPType. \n"
	"\tSupported Formats: 10.1.1.1 or f0f3:0013:e0b5: ..."
	"\n"

	"routeEntry.action.nTcpUdpPort :\n"
	"\tSession new TCP/UDP port number. Used if eSessionRoutingMode is NAPT \n"
	"\n"
	"routeEntry.action.nMTUvalue :\n"
	"\tSession MTU value. \n"
	"\n"
	"routeEntry.action.bMAC_SrcEnable :\n"
	"\tSource MAC address used\n"
	"\n"
	"routeEntry.action.nSrcMAC :\n"
	"\tSource MAC address\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"routeEntry.action.bMAC_DstEnable :\n"
	"\tDestination MAC address used\n"
	"\n"
	"routeEntry.action.nDstMAC :\n"
	"\tDestination MAC address\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n"
	"routeEntry.action.bPPPoEmode :\n"
	"\tSession PPPoE mode\n"
	"\t0:PPPoE Mode transparent, 1:PPPoE Mode Termination"
	"\n"
	"routeEntry.action.nPPPoESessId :\n"
	"\tSession PPPoE Session Identifier used\n"
	"\n"
	"routeEntry.action.bTunnel_Enable :\n"
	"\tTunnel used\n"
	"\n"
	"routeEntry.action.eTunType :\n"
	"\tTunnel type/mode\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_TUNL_NULL. Session routing tunnel type is No Tunnel action.\n"
	"\n"
	"\t1: GSW_ROUTE_TUNL_6RD. Session routing tunnel type is 6rd.\n"
	"\n"
	"\t2: GSW_ROUTE_TUNL_DSLITE. Session routing tunnel type is DSlite\n"
	"\n"
	"\t3: GSW_ROUTE_TUNL_L2TP. Session routing tunnel type is L2TP.\n"
	"\n"
	"\t4: GSW_ROUTE_TUNL_IPSEC. Session routing tunnel type is IPsec.\n"
	"\n"
	"routeEntry.action.nTunnelIndex :\n"
	"\tPreconfigured tunnel Index. The tunnel Index maps to Tunnel table.\n"
	"\n"
	"routeEntry.action.bMeterAssign :\n"
	"\tMeterId assignment action. 0:Assignment disabled, 1:Assignment Enabled\n"
	"\n"
	"routeEntry.action.nMeterId :\n"
	"\tMeter Id used for the session. The metering configuration can be done using\n"
	"\tdiffernt switch api function. Meter index (zero-based counting).\n"
	"\n"
	"routeEntry.action.bRTPMeasEna :\n"
	"\tRTP Multicast session's sequence number counter Action.\n"
	"\tValue: 0:Assignment disabled, 1:Assignment Enabled\n"
	"\n"

	"routeEntry.action.nRTPSeqNumber :\n"
	"\tRTP sequence number for which the multicast packet will be counted.\n"
	"\n"
	"routeEntry.action.nRTPSessionPktCnt :\n"
	"\tRTP packet Rolling Counter. R-O \n"
	"\n"
	"routeEntry.action.nFID :\n"
	"\tSession FID. Value 0-63, Session FID is used for Egress VLAN action\n"
	"\n"
	"routeEntry.action.nFlowId :\n"
	"\tFlow Id value. Value 0-255. Default value is 0.\n"
	"\n"
	"routeEntry.action.eOutDSCPAction :\n"
	"\tOuter DSCP remarking action - Valid for Tunnel associated entries.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_OUT_DSCP_NULL. Session routing no outer DSCP remarking action.\n"
	"\n"
	"\t1: GSW_ROUTE_OUT_DSCP_INNER. Session routing outer DSCP from inner IP header.\n"
	"\n"
	"\t2: GSW_ROUTE_OUT_DSCP_SESSION. Session routing outer DSCP from session action table.\n"
	"\n"
	"\t3: GSW_ROUTE_OUT_DSCP_RES. Session routing outer DSCP action reserved.\n"
	"\n"
	"routeEntry.action.bInnerDSCPRemark :\n"
	"\tSession routing inner DSCP remarking action.\n"
	"\tValue: 0:No remarking., 1:remarking based on session.\n"
	"\n"
	"routeEntry.action.nDSCP :\n"
	"\tDSCP remarking value for the session.\n"
	"\n"
	"routeEntry.action.bTCremarking :\n"
	"\tRouting session traffic class remarking action..\n"
	"\tValue: 0:No remarking. 1:TC remarking enabled.\n"
	"\n"
	"routeEntry.action.nTrafficClass :\n"
	"\tTraffic class remarking value for the session.\n"
	"\n"
	"routeEntry.action.nSessionCtrs :\n"
	"\tSession MIB Counters.\n"
	"\n"

	"routeEntry.action.eSessDirection :\n"
	"\tRouting Session Directions, LAN or WAN \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_DIRECTION_DNSTREAM. Session is LAN egress i.e WAN Downstream.\n"
	"\n"
	"\t1: GSW_ROUTE_DIRECTION_UPSTREAM. Session is LAN ingress i.e. WAN Upstream session.\n"
	"\n"

	"routeEntry.action.eSessRoutingMode :\n"
	"\tSession routing action mode. Routing mode\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_MODE_NULL. Session routing type NULL ?? Bridge session.\n"
	"\n"
	"\t1: GSW_ROUTE_MODE_ROUTING. Session routing type plain routing.\n"
	"\n"
	"\t2: GSW_ROUTE_MODE_NAT. Session routing type is Src IP address NAT.\n"
	"\n"
	"\t3: GSW_ROUTE_MODE_NAPT. Session routing type is Src IP/Port NAT.\n"
	"\n"

	"routeEntry.action.bTTLDecrement :\n"
	"\tEnable TTL decrement for the session.\n"
	"\tValue: 0:TTL decrement disabled, 1:TTL decrement enabled.\n"
	"\n"
	"routeEntry.action.bHitStatus :\n"
	"\tSession hit Status - RW.\n"
	"\n",

	/* 155: GSW_ROUTE_TUNNEL_ENTRY_READ */
	"This command reads the Tunnel values from the routing Tunnel table at a\n"
	"given specified Tunnel Index. A Tunnel entry can be written\n"
	"using the command \ref GSW_ROUTE_TUNNEL_ENTRY_ADD.\n"
	"Parameter:\n----------\n"
	"nTunIndex :\n"
	"\tTunnel table entry index.\n"
	"tunnelEntry.eTunnelType :\n"
	"\tTunnel type enum for DSLite, 6RD, IPSec, L2TP .\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_TUNL_NULL. Session routing tunnel type is No Tunnel action.\n"
	"\n"
	"\t1: GSW_ROUTE_TUNL_6RD. Session routing tunnel type is 6rd.\n"
	"\n"
	"\t2: GSW_ROUTE_TUNL_DSLITE. Session routing tunnel type is DSlite\n"
	"\n"
	"\t3: GSW_ROUTE_TUNL_L2TP. Session routing tunnel type is L2TP.\n"
	"\n"
	"\t4: GSW_ROUTE_TUNL_IPSEC. Session routing tunnel type is IPsec.\n"
	"\n"
	"\n",

	/* 156: GSW_ROUTE_TUNNEL_ENTRY_DELETE */
	"This command deletes  a specified Tunnel entry in the Routing Tunnel table.\n"
	"The Tunnel entry can be read using the commnad \ref GSW_ROUTE_TUNNEL_ENTRY_READ.\n"
	"Parameter:\n----------\n"
	"nTunIndex :\n"
	"\tTunnel table entry index.\n"
	"tunnelEntry.eTunnelType :\n"
	"\tTunnel type enum for DSLite, 6RD, IPSec, L2TP .\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_TUNL_NULL. Session routing tunnel type is No Tunnel action.\n"
	"\n"
	"\t1: GSW_ROUTE_TUNL_6RD. Session routing tunnel type is 6rd.\n"
	"\n"
	"\t2: GSW_ROUTE_TUNL_DSLITE. Session routing tunnel type is DSlite\n"
	"\n"
	"\t3: GSW_ROUTE_TUNL_L2TP. Session routing tunnel type is L2TP.\n"
	"\n"
	"\t4: GSW_ROUTE_TUNL_IPSEC. Session routing tunnel type is IPsec.\n"
	"\n"
	"tunnelEntry.t.tun6RD.nSrcIP4Addr :\n"
	"\t6rd tunnel Source IPv4 address. 6rd tunnel interface - Outer IPv4\n"
	"\tSupported Formats: 10.1.1.1 "
	"\n"
	"tunnelEntry.t.tun6RD.nDstIP4Addr :\n"
	"\t6rd tunnel Dest IPv4 address. 6rd tunnel interface - Outer IPv4\n"
	"\tSupported Formats: 10.1.1.1"
	"\n"
	"tunnelEntry.t.nTunL2TP :\n"
	"\tL2TP tunnel configuration.\n"
	"\n"
	"tunnelEntry.t.nTunIPsec :\n"
	"\tIPsec crypto context configuration..\n"
	"\n"
	"tunnelEntry.t.tunDSlite.nSrcIP6Addr :\n"
	"\tDS-Lite tunnel Source IPv6 address. DSLite tunnel interface - Outer IPv6\n"
	"\tSupported Formats: f0f3:0013:e0b5: ..."
	"\n"
	"tunnelEntry.t.tunDSlite.nDstIP6Addr :\n"
	"\tDS-Lite tunnel Dest IPv6 address. DSLite tunnel interface - Outer IPv6.\n"
	"\tSupported Formats: f0f3:0013:e0b5: ..."
	"\n"
	"\n",

	/* 157: GSW_ROUTE_TUNNEL_ENTRY_ADD */
	"This command adds a new Tunnel entry in the Routing Tunnel table.\n"
	"The Tunnel entry can be read using the commnad GSW_ROUTE_TUNNEL_ENTRY_READ.\n"
	"Parameter:\n----------\n"
	"nTunIndex :\n"
	"\tTunnel table entry index.\n"
	"tunnelEntry.eTunnelType :\n"
	"\tTunnel type enum for DSLite, 6RD, IPSec, L2TP .\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_TUNL_NULL. Session routing tunnel type is No Tunnel action.\n"
	"\n"
	"\t1: GSW_ROUTE_TUNL_6RD. Session routing tunnel type is 6rd.\n"
	"\n"
	"\t2: GSW_ROUTE_TUNL_DSLITE. Session routing tunnel type is DSlite\n"
	"\n"
	"\t3: GSW_ROUTE_TUNL_L2TP. Session routing tunnel type is L2TP.\n"
	"\n"
	"\t4: GSW_ROUTE_TUNL_IPSEC. Session routing tunnel type is IPsec.\n"
	"\n"

	"tunnelEntry.t.tun6RD.nSrcIP4Addr :\n"
	"\t6rd tunnel Source IPv4 address. 6rd tunnel interface - Outer IPv4\n"
	"\tSupported Formats: 10.1.1.1 "
	"\n"

	"tunnelEntry.t.tun6RD.nDstIP4Addr :\n"
	"\t6rd tunnel Dest IPv4 address. 6rd tunnel interface - Outer IPv4\n"
	"\tSupported Formats: 10.1.1.1"
	"\n"

	"tunnelEntry.t.nTunL2TP :\n"
	"\tL2TP tunnel configuration.\n"
	"\n"
	"tunnelEntry.t.nTunIPsec :\n"
	"\tIPsec crypto context configuration..\n"
	"\n"

	"tunnelEntry.t.tunDSlite.nSrcIP6Addr :\n"
	"\tDS-Lite tunnel Source IPv6 address. DSLite tunnel interface - Outer IPv6\n"
	"\tSupported Formats: f0f3:0013:e0b5: ..."
	"\n"

	"tunnelEntry.t.tunDSlite.nDstIP6Addr :\n"
	"\tDS-Lite tunnel Dest IPv6 address. DSLite tunnel interface - Outer IPv6.\n"
	"\tSupported Formats: f0f3:0013:e0b5: ..."
	"\n"

	"\n",

	/* 158: GSW_ROUTE_L2NAT_CFG_READ */
	"This command reads L2NAT configurations on specified egress port of PAE.\n"
	"Parameter:\n----------\n"
	"nEgPortId :\n"
	"\tEgress Port Id.\n"
	"\n",

	/* 159: GSW_ROUTE_L2NAT_CFG_WRITE */
	"This command configures L2NAT on egress port of PAE. When enabled the \n"
	"Source MAC Address of traffic leaving specified egress port would be \n"
	"NAT-ed with configrued MAC address. \n"
	"Parameter:\n----------\n"
	"bL2NATEna :\n"
	"\tEnable L2NAT on this egress port of PAE\n"
	"\n"
	"nEgPortId :\n"
	"\tEgress Port Id.\n"
	"\n"
	"nNatMAC :\n"
	"\tNew source MAC address for L2NAT on this egress port\n"
	"\tSupported Formats: 12:34:45:67:89:0A"
	"\n",

	/* 160: GSW_ROUTE_SESSION_HIT_OP */
	"This command reads or reads-n-clears Hit-Status for high priority sessions. \n"
	"Parameter:\n----------\n"
	"nRtIndex :\n"
	"\tRouting Session Index\n"
	"\n"
	"eHitOper :\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0: GSW_ROUTE_HIT_READ. Session routing Hit Status Read Action \n"
	"\n"
	"\t1: GSW_ROUTE_HIT_CLEAR. Session routing Hit Status Clear Action\n"
	"\n"
	"\n",

	/* 161: GSW_ROUTE_SESSION_DEST_MOD */
	"This command modifies the destination of an existing Routing session. \n"
	"Parameter:\n----------\n"
	"nRtIdx :\n"
	"\tSession Index \n"
	"\n"
	"nDstPortMap :\n"
	"\tSession destination port map. LSB refers to Port 0.\n"
	"\n"
	"nDstSubIfId :\n"
	"\tSession destination sub-interace Id.\n"
	"\n"
	"\n",
#endif
	/* 162: GSW_CTP_PORT_ASSIGNMENT_SET"*/
	"GSW_CTP_PORT_ASSIGNMENT_SET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1. nLogicalPortId\n"
	"\t2. nFirstCtpPortId\n"
	"\t3. nNumberOfCtpPort\n"
	"\t4. eMode\n",
	/* 163: GSW_CTP_PORT_ASSIGNMENT_GET"*/
	"GSW_CTP_PORT_ASSIGNMENT_GET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1. nLogicalPortId\n",
	/* 164: GSW_EXTENDEDVLAN_SET"*/
	"Set Extended VLAN Configuration entry. Valid for GSWIP-3.1\n"
	"It is used to set Extended VLAN Configuration entry\n"
	"Supported Parameters:\n"
	"---------------------\n\n"
	"nExtendedVlanBlockId\n"
	"\tThis should be valid ID returned by GSW_EXTENDEDVLAN_ALLOC\n"
	"\t If it is INVALID_HANDLE, GSW_EXTENDEDVLAN_config_t::nEntryIndex\n"
	"\tis absolute index of Extended VLAN entry in hardware for debug purpose\n"
	"\tbypassing any check\n"
	"nEntryIndex\n"
	"\t Index of entry\n"
	"eOuterVlanFilterVlanType\n"
	"\tIndex of entry, ranges between 0 and\n"
	"\t SW_EXTENDEDVLAN_alloc_t::nNumberOfEntries - 1, to\n"
	"\tGSW_EXTENDEDVLAN_SET) or get ref GSW_EXTENDEDVLAN_GET)\n"
	"\tExtended VLAN Configuration entry. For debug purpose, this field could be\n"
	"\tabsolute index of Entended VLAN entry in hardware, when\n"
	"\tGSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId is\n"
	"\tINVALID_HANDLE\n"
	"** Filter for outer VLAN tag. *\n"
	"-------------------------------\n"
	"\teOuterVlanFilterVlanType\n"
	"\t** Filter Type: normal filter, default rule, or no tag\n"
	"\tSupported Values:\n"
	"\t0: There is tag and criteria applies\n"
	"\t1 There is tag but no criteria\n"
	"\t2:Default entry if no other rule applies\n"
	"\t3 There is no tag\n"
	"\t4:Block invalid\n"
	"\tbOuterVlanFilterPriorityEnable\n"
	"\t** Enable priority field filtering *\n"
	"\tnOuterVlanFilterPriorityVal\n"
	"\t** Filter priority value if bPriorityEnable is TRUE.\n"
	"\tbOuterVlanFilterVidEnable\n"
	"\t** Enable VID filtering. *\n"
	"\tnOuterVlanFilterVidVal\n"
	"\t** Filter VID if bVidEnable is TRUE\n"
	"\teOuterVlanFilterTpid\n"
	"\t** Mode to filter TPID of VLAN tag \n"
	"\t-------------------\n"
	"\tSupported Values:\n"
	"\t0: ** Do not filter. *\n"
	"\t1 ** TPID is 0x8100. * \n"
	"\t2:** TPID is global configured value. *\n"
	"\teOuterVlanFilterDei\n"
	"\t** Mode to filter DEI of VLAN tag\n"
	"\t-------------------\n"
	"\tSupported Values:\n"
	"\t0: ** Do not filter. *\n"
	"\t1 ** DEI is 0  \n"
	"\t2:** DEI is 1  \n"
	"** Filter for Inner VLAN tag. *\n"
	"-------------------------------\n"
	"\teInnerVlanFilterVlanType\n"
	"\t** Filter Type: normal filter, default rule, or no tag\n"
	"\tSupported Values:\n"
	"\t0: There is tag and criteria applies\n"
	"\t1 There is tag but no criteria\n"
	"\t2:Default entry if no other rule applies\n"
	"\t3 There is no tag\n"
	"\t4:Block invalid\n"
	"\tbInnerVlanFilterPriorityEnable\n"
	"\t** Enable priority field filtering *\n"
	"\tnInnerVlanFilterPriorityVal\n"
	"\t** Filter priority value if bPriorityEnable is TRUE.\n"
	"\tbInnerVlanFilterVidEnable\n"
	"\t** Enable VID filtering. *\n"
	"\tnInnerVlanFilterVidVal\n"
	"\t** Filter VID if bVidEnable is TRUE\n"
	"\teInnerVlanFilterTpid\n"
	"\t** Mode to filter TPID of VLAN tag \n"
	"\t-------------------\n"
	"\tSupported Values:\n"
	"\t0: ** Do not filter. *\n"
	"\t1 ** TPID is 0x8100. * \n"
	"\t2:** TPID is global configured value. *\n"
	"\teInnerVlanFilterDei\n"
	"\t** Mode to filter DEI of VLAN tag\n"
	"\t-------------------\n"
	"\tSupported Values:\n"
	"\t0: ** Do not filter. *\n"
	"\t1 ** DEI is 0  \n"
	"\t2:** DEI is 1  \n"
	"eEtherType\n"
	"\t** Filter EtherType. *\n"
	"\tSupported Values:\n"
	"\t0: ** Do not filter. *\n"
	"\t1: ** IPoE frame (Ethertyp is 0x0800)\n"
	"\t2: ** PPPoE frame (Ethertyp is 0x8863 or 0x8864)\n"
	"\t3: ** ARP frame (Ethertyp is 0x0806)\n"
	"\t4: ** IPv6 IPoE frame (Ethertyp is 0x86DD)\n"
	"eRemoveTagAction\n"
	"\t** Number of VLAN tag(s) to remove. *\n"
	"\tSupported Values:\n"
	"\t0:** Do not remove VLAN tag. *\n"
	"\t1:** Remove 1 VLAN tag following DA/SA. *\n"
	"\t2:** Remove 2 VLAN tag following DA/SA. *\n"
	"\t3:** Discard upstream traffic. *\n"
	"bOuterVlanActionEnable\n"
	"\t** Enable outer VLAN tag add/modification. *\n"
	"Treatment for outer VLAN tag. *\n"
	"\t-------------------\n"
	"\teOuterVlanActionPriorityMode\n"
	"\t** Select source of priority field of VLAN tag. *\n"
	"\tSupported Values:\n"
	"\t0 /** Set priority with given value. */\n"
	"\t1 /** Prority value is copied from inner VLAN tag of received packet. */\n"
	"\t2 /** Prority value is copied from outer VLAN tag of received packet. */\n"
	"\t3 /** Prority value is derived from DSCP field of received packet. */\n"
	"eOuterVlanActionPriorityVal\n"
	"\t** If  GSW_EXTENDEDVLAN_treatmentVlan_t::ePriorityMode is\n"
	"\tGSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL, use this value for\n"
	"\tpriority field of VLAN tag. *\n"
	"eOuterVlanActionVidMode\n"
	"\t** Select source of VID field of VLAN tag. *\n"
	"\tSupported Values:\n"
	"\t0:/** Set VID with given value. */\n"
	"\t1:/** VID is copied from inner VLAN tag of received packet. */\n"
	"\t2:/** VID is copied from outer VLAN tag of received packet. */\n"
	"eOuterVlanActionVidVal\n"
	"\t** If GSW_EXTENDEDVLAN_treatmentVlan_t::eVidMode is\n"
	"\tGSW_EXTENDEDVLAN_TREATMENT_VID_VAL, use this value for VID field\n"
	"\tof VLAN tag\n"
	"eOuterVlanActionTpid\n"
	"\t/** Select source of TPID field of VLAN tag. */\n"
	"\tSupported Values:\n"
	"\t0:/** TPID is copied from inner VLAN tag of received packet. */\n"
	"\t1:/** TPID is copied from outer VLAN tag of received packet. */\n"
	"\t2:/** TPID is global configured value. */\n"
	"\t3:/** TPID is 0x8100. */\n"
	"eOuterVlanActioneDei\n"
	"\t/** Select source of DEI field of VLAN tag. */\n"
	"\t:Supported Values:\n"
	"\t0:/** DEI (if applicable) is copied from inner VLAN tag of received packet. */\n"
	"\t1:/** DEI (if applicable) is copied from outer VLAN tag of received packet. */\n"
	"\t2:/** DEI is 0. */\n"
	"\t3:/** DEI is 1. */\n"
	"Treatment for inner VLAN tag. *\n"
	"\t------------------ -\n"
	"bInnerVlanActionEnable\n"
	"\t/** Enable inner VLAN tag add/modification. */\n"
	"eInnerVlanActionPriorityMode\n"
	"\t **Select source of priority field of VLAN tag. *\n"
	"\tSupported Values :\n"
	"\t0 /** Set priority with given value. */\n"
	"\t1 /** Prority value is copied from inner VLAN tag of received packet. */\n"
	"\t2 /** Prority value is copied from outer VLAN tag of received packet. */\n"
	"\t3 /** Prority value is derived from DSCP field of received packet. */\n"
	"eInnerVlanActionPriorityVal\n"
	"\t **If  GSW_EXTENDEDVLAN_treatmentVlan_t::ePriorityMode is\n"
	"\tGSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL, use this value for \n"
	"\tpriority field of VLAN tag. *\n"
	"eInnerVlanActionVidMode\n"
	"\t **Select source of VID field of VLAN tag. *\n"
	"\tSupported Values :\n"
	"\t0 :/** Set VID with given value. */\n"
	"\t1 :/** VID is copied from inner VLAN tag of received packet. */\n"
	"\t2 :/** VID is copied from outer VLAN tag of received packet. */\n"
	"eInnerVlanActionVidVal\n"
	"\t **If GSW_EXTENDEDVLAN_treatmentVlan_t::eVidMode is\n"
	"\tGSW_EXTENDEDVLAN_TREATMENT_VID_VAL, use this value for VID field\n"
	"\tof VLAN tag\n"
	"eInnerVlanActionTpid\n"
	"\t/** Select source of TPID field of VLAN tag. */\n"
	"\tSupported Values :\n"
	"\t0 :/** TPID is copied from inner VLAN tag of received packet. */\n"
	"\t1 :/** TPID is copied from outer VLAN tag of received packet. */\n"
	"\t2 :/** TPID is global configured value. */\n"
	"\t3 :/** TPID is 0x8100. */\n"
	"eInnerVlanActioneDei\n"
	"\t/** Select source of DEI field of VLAN tag. */\n"
	"\t :Supported Values :\n"
	"\t0 :/** DEI (if applicable) is copied from inner VLAN tag of received packet. */\n"
	"\t1 :/** DEI (if applicable) is copied from outer VLAN tag of received packet. */\n"
	"\t2 :/** DEI is 0. */\n"
	"\t3 :/** DEI is 1. */\n"
	"bReassignBridgePortEnable\n"
	"\t/** Enable re-assignment of bridge port. */\n"
	"nNewBridgePortId\n"
	"\t/** If bReassignBridgePort is TRUE, use this value for bridge port. */\n"
	"bNewDscpEnable\n"
	"\t/** Enable new DSCP. */\n"
	"nNewDscp\n"
	"\t/** If bNewDscpEnable is TRUE, use this value for DSCP. */\n"
	"bNewTrafficClassEnable\n"
	"\t/** Enable new traffic class. */\n"
	"nNewTrafficClass\n"
	"\t/** If bNewTrafficClassEnable is TRUE, use this value for traffic class. */\n"
	"bNewMeterEnable\n"
	"\t/** Enable new meter. */\n"
	"sNewTrafficMeterId\n"
	"\t/** New meter ID.\n"
	"\tremarks\n"
	"\tMeter should be allocated with ref GSW_QOS_METER_ALLOC before extended\n"
	"\tVLAN treatment is added. If this extended VLAN treatment is deleted \n"
	"\tthis meter should be released with ref GSW_QOS_METER_FREE. */\n"
	"bLoopbackEnable\n"
	"\t/** Enable loopback. */\n"
	"bDaSaSwapEnable\n"
	"\t/** Enable destination/source MAC address swap. */\n"
	"bMirrorEnable\n"
	"\t/** Enable traffic mirrored to the monitoring port. */\n"
	"bDscp2PcpMapEnable\n"
	"\t"
	"nDscp2PcpMapValue\n"
	"\t/** DSCP to PCP mapping, if\n"
	"\tref GSW_EXTENDEDVLAN_treatmentVlan_t::ePriorityMode in\n"
	"\tref GSW_EXTENDEDVLAN_treatment_t::sOuterVlan.ePriorityMode or\n"
	"\tref GSW_EXTENDEDVLAN_treatment_t::sInnerVlan.ePriorityMode is\n"
	"\tref GSW_EXTENDEDVLAN_TREATMENT_DSCP.\n"
	"\tremarks\n"
	"\tThe index of array stands for DSCP value. Each byte of the array is 3-bit\n"
	"\tPCP value. For implementation, if DSCP2PCP is separate hardware table,\n"
	"\ta resource management mechanism should be implemented. Allocation happens\n"
	"\twhen extended VLAN treatment added, and release happens when the\n"
	"\ttreatment is deleted. For debug, the DSCP2PCP table can be dumped with\n"
	"\tref GSW_DSCP2PCP_MAP_GET. */\n",
	/* 165: GSW_EXTENDEDVLAN_GET"*/
	"Get Extended VLAN Configuration entry. Valid for GSWIP-3.1.\n"
	"It is used to get Extended VLAN Configuration entry with index\n"
	"ref GSW_EXTENDEDVLAN_config_t::nEntryIndex, ranging between 0 and\n"
	"ref GSW_EXTENDEDVLAN_alloc_t::nNumberOfEntries - 1, with valid\n"
	"ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId returned by\n"
	"ref GSW_EXTENDEDVLAN_ALLOC.\n"
	"If ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId is\n"
	"ref INVALID_HANDLE, this is absolute index of Extended VLAN Configuration\n"
	"entry in hardware, used for debugging purpose.\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"nExtendedVlanBlockId\n"
	"\tThis should be valid ID returned by GSW_EXTENDEDVLAN_ALLOC\n"
	"\t If it is INVALID_HANDLE, GSW_EXTENDEDVLAN_config_t::nEntryIndex\n"
	"\tis absolute index of Extended VLAN entry in hardware for debug purpose\n"
	"\tbypassing any check\n"
	"nEntryIndex\n"
	"\t Index of entry\n",
	/* 166: GSW_EXTENDEDVLAN_FREE"*/
	"Release Extended VLAN Configuration block. Valid for GSWIP-3.1.\n"
	"It is used to release Extended VLAN Configuration block allocated by\n"
	"ref GSW_EXTENDEDVLAN_ALLOC.\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"nExtendedVlanBlockId\n"
	"\t/** Total number of extended VLAN entries are requested. Proper value should\n"
	"\tbe given for ref GSW_EXTENDEDVLAN_ALLOC. This field is ignored for\n"
	"\tref GSW_EXTENDEDVLAN_FREE. */\n",
	/* 167: GSW_VLANFILTER_SET"*/
	"Set VLAN Filter entry. Valid for GSWIP-3.1./\n"
	"It is used to set VLAN Filter entry with index/\n"
	"ref GSW_VLANFILTER_config_t::nEntryIndex, ranging between 0 and/\n"
	"ref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, with valid/\n"
	"ref GSW_VLANFILTER_config_t::nVlanFilterBlockId returned by/\n"
	"ref GSW_VLANFILTER_ALLOC./\n"
	"Ifref GSW_VLANFILTER_config_t::nVlanFilterBlockId is ref INVALID_HANDLE,/\n"
	"this is absolute index of VLAN Filter entry in hardware, used for debugging/\n"
	"purpose./\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"\tnVlanFilterBlockId\n"
	"\t/** This should be valid ID return by ref GSW_VLANFILTER_ALLOC.\n"
	"\tIf it is ref INVALID_HANDLE, ref GSW_VLANFILTER_config_t::nEntryIndex\n"
	"\tis absolute index of VLAN Filter entry in hardware for debug purpose,\n"
	"\tbypassing any check. */\n"
	"\tnEntryIndex\n"
	"\t/** Index of entry. ranges between 0 and\n"
	"\tref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, to\n"
	"\tset (ref GSW_VLANFILTER_SET) or get (ref GSW_VLANFILTER_GET)\n"
	"\tVLAN FIlter entry. For debug purpose, this field could be absolute index\n"
	"\tof VLAN Filter entry in hardware, when\n"
	"\tref GSW_VLANFILTER_config_t::nVlanFilterBlockId is\n"
	"\tref INVALID_HANDLE. */\n"
	"\teVlanFilterMask\n"
	"\t/** VLAN TCI filter mask mode.\n"
	"\tremarks\n"
	"\tIn GSWIP-3.1, this field of first entry in the block will applies to rest\n"
	"\tof entries in the same block. */\n"
	"\t Supported values:\n"
	"\t0:GSW_VLAN_FILTER_TCI_MASK_VID\n"
	"\t1:GSW_VLAN_FILTER_TCI_MASK_PCP\n"
	"\t2:GSW_VLAN_FILTER_TCI_MASK_TCI\n"
	"\tnVal\n"
	"\t/** This is value for VLAN filtering. It depends on\n"
	"\tref GSW_VLANFILTER_config_t::eVlanFilterMask.\n"
	"\tFor GSW_VLAN_FILTER_TCI_MASK_VID, this is 12-bit VLAN ID.\n"
	"\tFor GSW_VLAN_FILTER_TCI_MASK_PCP, this is 3-bit PCP field of VLAN tag.\n"
	"\tFor GSW_VLAN_FILTER_TCI_MASK_TCI, this is 16-bit TCI of VLAN tag. */\n"
	"\tbDiscardMatched\n"
	"\t/** Discard packet if match. */\n",
	/* 168: GSW_VLANFILTER_GET"*/
	"Get VLAN Filter Entry. Valid for GSWIP-3.1..\n"
	"It is used to get VLAN filter entry with index.\n"
	"ref GSW_VLANFILTER_config_t::nEntryIndex, ranging between 0 and.\n"
	"ref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, with valid.\n"
	"ref GSW_VLANFILTER_config_t::nVlanFilterBlockId returned by.\n"
	"ref GSW_VLANFILTER_ALLOC..\n"
	"If ref GSW_VLANFILTER_config_t::nVlanFilterBlockId is ref INVALID_HANDLE,.\n"
	"this is absolute index of VLAN Filter entry in hardware, used for debugging.\n"
	"purpose..\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"\tnVlanFilterBlockId\n"
	"\t/** This should be valid ID return by ref GSW_VLANFILTER_ALLOC.\n"
	"\tIf it is ref INVALID_HANDLE, ref GSW_VLANFILTER_config_t::nEntryIndex\n"
	"\tis absolute index of VLAN Filter entry in hardware for debug purpose,\n"
	"\tbypassing any check. */\n"
	"\tnEntryIndex\n"
	"\t/** Index of entry. ranges between 0 and\n"
	"\tref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, to\n"
	"\tset (ref GSW_VLANFILTER_SET) or get (ref GSW_VLANFILTER_GET)\n"
	"\tVLAN FIlter entry. For debug purpose, this field could be absolute index\n"
	"\tof VLAN Filter entry in hardware, when\n"
	"\tref GSW_VLANFILTER_config_t::nVlanFilterBlockId is\n"
	"\tref INVALID_HANDLE. */\n",
	/* 169: GSW_VLANFILTER_FREE"*/
	"Delete VLAN Filter Block. Valid for GSWIP-3.1.\n"
	"It is used to release VLAN Filter block allocated by\n"
	"ref GSW_VLANFILTER_ALLOC.\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"nVlanFilterBlockId\n"
	"\t/** If ref GSW_VLANFILTER_ALLOC is successful, a valid ID will be returned\n"
	"\tin this field. Otherwise, ref INVALID_HANDLE is returned in this field.\n"
	"\tFor ref GSW_EXTENDEDVLAN_FREE, this field should be valid ID returned by\n"
	"\tref GSW_VLANFILTER_ALLOC. */\n",
	/* 170: GSW_BRIDGE_CONFIG_SET"*/
	"GSW_BRIDGE_CONFIG_SET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.  bForce\n"
	"\t2.  nBridgeId\n"
	"\t3.  bMacLearningLimitEnable\n"
	"\t4.  nMacLearningLimit\n"
	"\t5.  nMacLearningCount\n"
	"\t6.  nLearningDiscardEvent\n"
	"\t7.  eForwardBroadcast\n"
	"\t8.  eForwardUnknownMulticastIp\n"
	"\t9.  eForwardUnknownMulticastNonIp\n"
	"\t10. eForwardUnknownUnicast\n"
	"\t11. bBroadcastMeterEnable\n"
	"\t12. nBroadcastMeterId\n"
	"\t13. bMulticastMeterEnable\n"
	"\t14. nMulticastMeterId\n"
	"\t15. bUnknownMulticastIpMeterEnable\n"
	"\t16. nUnknownMulticastIpMeterId\n"
	"\t17. bUnknownMulticastNonIpMeterEnable\n"
	"\t18. nUnknownMulticastNonIpMeterId\n"
	"\t19. bUnknownUniCastMeterEnable\n"
	"\t20. nUnknownUniCastMeterId\n",
	/* 171: GSW_BRIDGE_CONFIG_GET"*/
	"GSW_BRIDGE_CONFIG_GET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.  nBridgeId\n",
	/* 172: GSW_BRIDGE_FREE"*/
	"GSW_BRIDGE_FREE\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  nBridgeId\n",
	/* 173: GSW_CTP_PORT_CONFIG_SET"*/
	"GSW_CTP_PORT_CONFIG_SET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.  bForce\n"
	"\t2.  nLogicalPortId\n"
	"\t3.  nSubIfIdGroup\n"
	"\t4.  nBridgePortId\n"
	"\t5.  bForcedTrafficClass\n"
	"\t6.  nDefaultTrafficClass\n"
	"\t7.  bIngressExtendedVlanEnable\n"
	"\t8.  nIngressExtendedVlanBlockId\n"
	"\t9.  bIngressExtendedVlanIgmpEnable\n"
	"\t10. nIngressExtendedVlanBlockIdIgmp\n"
	"\t11. bEgressExtendedVlanEnable\n"
	"\t12. nEgressExtendedVlanBlockId\n"
	"\t13. bEgressExtendedVlanIgmpEnable\n"
	"\t14. nEgressExtendedVlanBlockIdIgmp\n"
	"\t15. bIngressNto1VlanEnable\n"
	"\t16. bEgressNto1VlanEnable\n"
	"\t17. eIngressMarkingMode\n"
	"\t18. eEgressMarkingMode\n"
	"\t19. bEgressMarkingOverrideEnable\n"
	"\t20. eEgressRemarkingMode\n"
	"\t21. bIngressMeteringEnable\n"
	"\t22. nIngressTrafficMeterId\n"
	"\t23. bEgressMeteringEnable	\n"
	"\t24. nEgressTrafficMeterId	\n"
	"\t25. bBridgingBypass\n"
	"\t26. nDestLogicalPortId\n"
	"\t27. nDestSubIfIdGroup\n"
	"\t28. bPmapperEnable\n"
	"\t29. ePmapperMappingMode\n"
	"\t30. nFirstFlowEntryIndex\n"
	"\t31. nNumberOfFlowEntries\n"
	"\t32. bIngressLoopbackEnable\n"
	"\t33. bIngressDaSaSwapEnable\n"
	"\t34. bEgressLoopbackEnable\n"
	"\t35. bEgressDaSaSwapEnable\n"
	"\t36. bIngressMirrorEnable\n"
	"\t37. bEgressMirrorEnable\n",
	/* 174: GSW_CTP_PORT_CONFIG_GET"*/
	"GSW_CTP_PORT_CONFIG_GET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t2.  nLogicalPortId\n"
	"\t3.  nSubIfIdGroup\n",
	/* 175: GSW_CTP_PORT_CONFIG_RESET"*/
	"GSW_CTP_PORT_CONFIG_RESET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.  bForce\n"
	"\t2.  nLogicalPortId\n"
	"\t3.  nSubIfIdGroup\n",
	/* 176: GSW_BRIDGE_PORT_CONFIG_SET"*/
	"GSW_BRIDGE_PORT_CONFIG_SET\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.  bForce\n"
	"\t2.  nBridgePortId\n"
	"\t3.  nBridgeId\n"
	"\t4.  bIngressExtendedVlanEnable\n"
	"\t5.  nIngressExtendedVlanBlockId\n"
	"\t6.  bEgressExtendedVlanEnable\n"
	"\t7.  nEgressExtendedVlanBlockId\n"
	"\t8.  eIngressMarkingMode\n"
	"\t9.  eEgressRemarkingMode\n"
	"\t10. bIngressMeteringEnable\n"
	"\t11. nIngressTrafficMeterId\n"
	"\t12. bEgressMeteringEnable\n"
	"\t13. nEgressTrafficMeterId\n"
	"\t14. bEgressBroadcastSubMeteringEnable\n"
	"\t15. nEgressBroadcastSubMeteringId\n"
	"\t16. bEgressMulticastSubMeteringEnable\n"
	"\t17. nEgressMulticastSubMeteringId\n"
	"\t18. bEgressUnknownMulticastIPSubMeteringEnable\n"
	"\t19. nEgressUnknownMulticastIPSubMeteringId\n"
	"\t20. bEgressUnknownMulticastNonIPSubMeteringEnable\n"
	"\t21. nEgressUnknownMulticastNonIPSubMeteringId\n"
	"\t22. bEgressUnknownUnicastSubMeteringEnable\n"
	"\t23. nEgressUnknownUnicastSubMeteringId\n"
	"\t24. nDestLogicalPortId\n"
	"\t25. nDestSubIfIdGroup\n"
	"\t26. bPmapperEnable\n"
	"\t27. ePmapperMappingMode\n"
	"\t28. bBridgePortMapEnable\n"
	"\t\t Index\n"
	"\t\t MapValue\n"
	"\t29. bMcDestIpLookupDisable\n"
	"\t30. bMcSrcIpLookupEnable\n"
	"\t31. bDestMacLookupDisable\n"
	"\t32. bSrcMacLearningDisable\n"
	"\t33. bMacSpoofingDetectEnable\n"
	"\t34. bPortLockEnable\n"
	"\t35. bMacLearningLimitEnable\n"
	"\t36. bIngressVlanFilterEnable\n"
	"\t37. nIngressVlanFilterBlockId\n"
	"\t38. bBypassEgressVlanFilter1\n"
	"\t39. bEgressVlanFilter1Enable\n"
	"\t40. nEgressVlanFilter1BlockId\n"
	"\t41. bEgressVlanFilter2Enable\n"
	"\t42. nEgressVlanFilter2BlockId\n",
	/* 177: GSW_BRIDGE_PORT_CONFIG_GET"*/
	"GSW_BRIDGE_PORT_CONFIG_GET\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  nBridgePortId\n",
	/* 178: GSW_BRIDGE_PORT_ALLOC"*/
	"GSW_BRIDGE_PORT_ALLOC\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  No Parameters needed\n",
	/* 179: GSW_BRIDGE_PORT_FREE"*/
	"GSW_BRIDGE_PORT_FREE\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  nBridgePortId\n",
	/* 180: GSW_EXTENDEDVLAN_ALLOC"*/
	"GSW_EXTENDEDVLAN_ALLO\nC",
	/* 181: GSW_VLANFILTER_ALLOC"*/
	"GSW_VLANFILTER_ALLOC\n",
	/* 182: GSW_BRIDGE_ALLOC"*/
	"GSW_BRIDGE_ALLOC\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  No Parameters needed\n",
	/* 183: GSW_PMAC_RMON_GET"*/
	"GSW_PMAC_RMON_GET\n",
	/* 184: GSW_DEBUG_CTPTABLE_STATUS"*/
	"GSW_DEBUG_CTPTABLE_STATUS\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1. Index\n"
	"\t2. CheckAll (0 or 1)\n",
	/* 185: GSW_DEBUG_BRDGPORTTABLE_STATUS"*/
	"GSW_DEBUG_BRDGPORTTABLE_STATUS\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1. Index\n"
	"\t2. CheckAll (0 or 1)\n",
	/* 186: GSW_DEBUG_BRDGTABLE_STATUS"*/
	"GSW_DEBUG_BRDGTABLE_STATUS\n"
	"\t\t---------------------\n\n"
	"\t1. Index\n",
	/* 187: GSW_DEBUG_EXVLANTABLE_STATUS"*/
	"GSW_DEBUG_EXVLANTABLE_STATUS\n",
	/* 188: GSW_PMAC_RMON_GET"*/
	"GSW_DEBUG_VLANFILTERTABLE_STATUS\n",
	/* 189: GSW_DEBUG_VLANFILTERTABLE_STATUS"*/
	"GSW_DEBUG_METERTABLE_STATUS\n",
	/* 190: GSW_DEBUG_DSCP2PCPTABLE_STATUS"*/
	"GSW_DEBUG_DSCP2PCPTABLE_STATUS\n",
	/* 191: GSW_DEBUG_PMAPPER_STATUS"*/
	"GSW_DEBUG_PMAPPER_STATUS\n",
	/* 192: GSW_DEBUG_PMAC_EG"*/
	"GSW_DEBUG_PMAC_EG\n",
	/* 193: GSW_DEBUG_PMAC_IG"*/
	"GSW_DEBUG_PMAC_IG\n",
	/* 194: GSW_DEBUG_PMAC_BP"*/
	"GSW_DEBUG_PMAC_IG\n",
	/* 195: GSW_DEBUG_DEF_QMAP"*/
	"GSW_DEBUG_DEF_QMAP\n",
	/* 196: GSW_DEBUG_DEF_BYP_QMAP"*/
	"GSW_DEBUG_DEF_BYP_QMAP\n",
	/* 197: xgmac"*/
	"GSW_XGMAC_CFG\n",
	/* 198: GSW_PMAC_BM_CFG_SET */
	"Configure the backpressure mapping table between Tx Queues for Egress and Rx Queues \n"
	"for Ingress congestion on given DMA channel. \n"
	"\nParameter:\n----------\n"
	"nTxDmaChanId :\n"
	"\tTx DMA Channel Identifier (0..15). \n"
	"txQMask :\n"
	"\tTransmit Queues Mask - Upto 32 Egress Queues. \n"
	"rxPortMask :\n"
	"\tReceive (Ingress) ports congestion Mask - Upto 16 ports. \n"
	"\n",

	/* 199: GSW_PMAC_EG_CFG_SET */
	"Configure the egress attributes on given PMAC ports. \n"
	"\nParameter:\n----------\n"
	"nDestPortId :\n"
	"\tDestination Port Identifier (0..15) - Part of Table Index (Bits 0-3). \n"
	"bProcFlagsSelect :\n"
	"\tSelector for Processing Flags (MPE1, MPE2, DEC & ENC bits). If disabled, \n"
	"\tthen the combination of flags bDecFlag, bEncFlag, bMpe1Flag and  bMpe2Flag\n"
	"\t are considered as index instead of nTrafficClass. For using these \n"
	"\tcombination flags, turn ON this boolean selector.\n"
	"\tTC or combination processing flag is decided at global \n"
	"\tlevel through bProcFlagsEgPMACEna.\n"
	"\tIt is expected that user always passes correct value based \n"
	"\tupon bProcFlagsEgMPACEna. If mismatch found with global PMAC mode,\n"
	"\t SWAPI will return error code.\n"
	"nTrafficClass :\n"
	"\tTraffic Class value [Lower 4 -bits (LSB-0, 1, 2, 3)].- Part of Table Index Bits 4-7.\n"
	"\tThis value is considered, only when bProcFlagsSelect is not set.\n"
	"nFlowIDMsb :\n"
	"\tFlow-ID MSB (2-bits) value -  valid range (0..2). - Part of Table Index Bits 8-9.\n"
	"bMpe1Flag :\n"
	"\tMPE-1 Flag value - Part of Table Index Bit 4. Valid only when bProcFlagsSelect is set\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  MPE-1 Marked Flag disabled.\n"
	"\n"
	"\t1:  MPE-1 Marked Flag Enabled.\n"
	"bMpe2Flag :\n"
	"\tMPE-2 Flag value - Part of Table Index Bit 5. Valid only when bProcFlagsSelect is set.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  MPE-2 Marked Flag disabled.\n"
	"\n"
	"\t1:  MPE-2 Marked Flag Enabled.\n"
	"bEncFlag :\n"
	"\tCryptography Encryption Action Flag value - Part of Table Index Bit 7.\n"
	"\t Valid only, when bProcFlagsSelect is set\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Cryptography Encryption Action Flag disabled.\n"
	"\n"
	"\t1:  Cryptography Encryption Action Flag Enabled.\n"
	"bDecFlag :\n"
	"\tCryptography Decryption Action Flag value - Part of Table Index Bit 6.\n"
	"\t Valid only, when bProcFlagsSelect is set.\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Cryptography Decryption Action Flag disabled.\n"
	"\n"
	"\t1:  Cryptography Decryption Action Flag Enabled.\n"
	"nRxDmaChanId :\n"
	"\tReceive DMA Channel Identifier (0..15) \n"
	"bRemL2Hdr :\n"
	"\t To remove L2 header & additional bytes (True) or Not (False) \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  L2 header is not removed.\n"
	"\n"
	"\t1:  L2 Header and byte after L2 header is removed.\n"
	"numBytesRem :\n"
	"\tNo. of bytes to be removed after Layer-2 Header, valid when bRemL2Hdr is set. \n"
	"bFcsEna :\n"
	"\tPacket has FCS (True) or Not (False). \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  The packet has no FCS.\n"
	"\n"
	"\t1:  The packet has FCS.\n"
	"bPmacEna :\n"
	"\tPacket has PMAC header or not. \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  The packet has no PMAC header.\n"
	"\n"
	"\t1:  The packet has PMAC header.\n"
	"nResDW1 :\n"
	"\t4-bits Reserved Field in DMA Descriptor - DW1 (bit 7 to 4). \n"
	"nRes1DW0 :\n"
	"\t3-bits Reserved Field in DMA Descriptor - DW0 (bit 31 to 29). \n"
	"nRes2DW0 :\n"
	"\t2-bits Reserved Field in DMA Descriptor - DW0 (bit 14 to 13). \n"
	"\n",

	/* 200: GSW_PMAC_IG_CFG_SET */
	"Read egress attributes config on given PMAC port. \n"
	"\nParameter:\n----------\n"
	"nTxDmaChanId :\n"
	"\tTx DMA Channel Identifier (0..15). \n"
	"bErrPktsDisc :\n"
	"\tError set packets to be discarded .\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Do not discard packet with error flag set\n"
	"\n"
	"\t1:  discard packet with error flag set.\n"
	"\n"
	"bPmapDefault :\n"
	"\tPort Map info from default PMAC header (True) or incoming PMAC header (False).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  PMAP from PMAC header.\n"
	"\n"
	"\t1:  PMAP from default PMAC header.\n"
	"\n"
	"bPmapEna :\n"
	"\tPort Map Enable info from default PMAC header (True) or incoming PMAC header (False).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  PMAP Enable from PMAC header.\n"
	"\n"
	"\t1:  PMAP Enable from default PMAC header.\n"
	"\n"
	"bClassDefault :\n"
	"\tClass Info from default PMAC header (True) or incoming PMAC header (False).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Class from Packet descriptor.\n"
	"\n"
	"\t1:  Class from from default PMAC header.\n"
	"\n"
	"bClassEna :\n"
	"\tClass Enable info from default PMAC header (True) or incoming PMAC header (False).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  Class Enable from Packet descriptor.\n"
	"\n"
	"\t1:  Class Enable from default PMAC header.\n"
	"\n"
	"bSubIdDefault :\n"
	"\tSub_Interface Id  Info from default PMAC header (True) or source \n"
	" sub-If in packet descriptor (False).\n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  SubID from Packet descriptor source SubInterface ID.\n"
	"\n"
	"\t1:  SubId from default PMAC header.\n"
	"\n"
	"bSpIdDefault :\n"
	"\tSource Port Id from default PMAC header (True) or incoming PMAC header (False) \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  SubID from PMAC header.\n"
	"\n"
	"\t1:  SPPID from default PMAC header.\n"
	"\n"
	"bPmacPresent :\n"
	"\tPacket PMAC header is present (True) or not (False) \n"
	"\tSupported Values:\n"
	"\t-----------------\n"
	"\t0:  The packet has no PMAC header.\n"
	"\n"
	"\t1:  The packet has PMAC header.\n"
	"\n"
	"defPmacHdr :\n"
	"\tDefault PMAC header - 8 Bytes Configuration .\n"
	"\tSupported Formats: 12:34:45:67:89:0A:0B:0C"
	"\n",
	/* 201: GSW_DEBUG_CTP_STATISTICS"*/
	"GSW_DEBUG_CTP_STATISTICS\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1. Index\n",
	/* 202: GSW_DEBUG_LP_STATISTICS"*/
	"GSW_DEBUG_LP_STATISTICS\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1. Index\n",
	/* 203: GSWSS "*/
	"GSW_GSWSS_CFG",
	/* 204: LMAC "*/
	"GSW_LMAC_CFG",
	/* 205: GSW_CTP_PORT_ASSIGNMENT_ALLOC "*/
	"GSW_CTP_PORT_ASSIGNMENT_ALLOC\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1. nLogicalPortId\n"
	"\t2. nNumberOfCtpPort\n"
	"\t3. eMode\n"
	"\t4. nBridgePortId\n",
	/* 206: GSW_CTP_PORT_ASSIGNMENT_FREE "*/
	"GSW_CTP_PORT_ASSIGNMENT_FREE"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1. nLogicalPortId\n",
	/* 207: MACSEC "*/
	"E160_MACSEC_CFG",
	/* 208: GSW_IRQ_REGISTER "*/
	"GSW_IRQ_REGISTER",

	/* 209: GSW_IRQ_UNREGISTER "*/
	"GSW_IRQ_UNREGISTER",

	/* 210: GSW_IRQ_ENABLE "*/
	"GSW_IRQ_ENABLE",

	/* 211: GSW_IRQ_DISBALE "*/
	"GSW_IRQ_DISBALE",

	/* 212: GSW_DEBUG_PRINT_PCEIRQ_LIST "*/
	"GSW_DEBUG_PRINT_PCEIRQ_LIST",
	/* 213: GSW_RMON_FLOW_GET "*/
	"GSW_RMON_FLOW_GET",
	/* 214: GSW_RMON_TFLOW_CLEAR "*/
	"GSW_RMON_TFLOW_CLEAR",
	/* 215: GSW_DSCP2PCP_MAP_GET "*/
	"GSW_DSCP2PCP_MAP_GET",
	/* 216: GSW_DEFAUL_MAC_FILTER_GET "*/
	"GSW_DEFAUL_MAC_FILTER_GET",
	/* 217: GSW_DEFAUL_MAC_FILTER_SET "*/
	"GSW_DEFAUL_MAC_FILTER_SET",
	/* 218: GSW_QOS_COLOR_MARKING_TABLE_SET "*/
	"GSW_QOS_COLOR_MARKING_TABLE_SET",
	/* 219: GSW_QOS_COLOR_MARKING_TABLE_GET "*/
	"GSW_QOS_COLOR_MARKING_TABLE_GET",
	/* 220: GSW_QOS_COLOR_REMARKING_TABLE_GET "*/
	"GSW_QOS_COLOR_REMARKING_TABLE_GET",
	/* 221: GSW_QOS_COLOR_REMARKING_TABLE_SET "*/
	"GSW_QOS_COLOR_REMARKING_TABLE_SET",
	/* 222: GSW_DEBUG_RMON_PORT_GET "*/
	"Read out the Ethernet port statistic counter (RMON counter). The zero-based\n"
	"'nPortId' structure element describes the logical/ctp/bridge switch port for the\n"
	"requested statistic information. - NOTE : used by test team and automation only\n"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"ePortType : \n",
	/* 223: GSW_CTP_PORT_RMON_GET "*/
	"Read out the Ethernet port statistic counter (RMON counter). The zero-based\n"
	"'nPortId' structure element describes the CTP switch port for the\n"
	"requested statistic information.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n",
	/* 224: GSW_BRIDGE_PORT_RMON_GET "*/
	"Read out the Ethernet port statistic counter (RMON counter). The zero-based\n"
	"'nPortId' structure element describes the Bridge switch port for the\n"
	"requested statistic information.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n",
	/* 225: GSW_CTP_PORT_PCEBYPASS_RMON_GET "*/
	"Read out the Ethernet port statistic counter (RMON counter). The zero-based\n"
	"'nPortId' structure element describes the CTP Bypass switch port for the\n"
	"requested statistic information.\n"
	"\nParameter:\n----------\n"
	"nPortId :\n",
	/* 226: GSW_RMON_PORT_GET_ALL "*/
	"Read out the Ethernet port statistic counter (RMON counter from nPortId 0 t0 8 - ctp or bridge. The zero-based\n"
	"\nParameter:\n----------\n"
	"ePortType :\n",

	/* 227: GSW_PBB_TUNNEL_TEMPLATE_ALLOC "*/
	"GSW_PBB_TUNNEL_TEMPLATE_ALLOC",
	/* 228: GSW_PBB_TUNNEL_TEMPLATE_FREE "*/
	"GSW_PBB_TUNNEL_TEMPLATE_FREE",
	/* 229: GSW_PBB_TUNNEL_TEMPLATE_SET "*/
	"GSW_PBB_TUNNEL_TEMPLATE_SET",
	/* 230: GSW_PBB_TUNNEL_TEMPLATE_GET "*/
	"GSW_PBB_TUNNEL_TEMPLATE_GET",

	/* 231: GSW_DEBUG_TUNNELTEMP_STATUS "*/
	"GSW_DEBUG_TUNNELTEMP_STATUS",
	/* 232: GSW_PMACBR_CLI "*/
	"GSW_PMACBR_CLI",

	/* 233: GSW_LPID_TO_GPID_ASSIGNMENT_SET "*/
	"GSW_LPID_TO_GPID_ASSIGNMENT_SET",
	/* 234: GSW_LPID_TO_GPID_ASSIGNMENT_GET "*/
	"GSW_LPID_TO_GPID_ASSIGNMENT_GET",
	/* 235: GSW_GPID_TO_LPID_ASSIGNMENT_SET "*/
	"GSW_GPID_TO_LPID_ASSIGNMENT_SET",
	/* 236: GSW_GPID_TO_LPID_ASSIGNMENT_GET "*/
	"GSW_GPID_TO_LPID_ASSIGNMENT_GET",
	/* 237: DUMP_MEM "*/
	"GSW_DUMP_MEM",
	/* 238: GSW_DEFAUL_PCE_QMAP_GET "*/
	"Read out the default PCE Q-MAP"
	"\nParameter:\n----------\n"
	"nPortId :\n",
	/* 239: GSW_DEFAUL_PCE_BYPASS_QMAP_GET "*/
	"Read out the default PCE Bypass Q-MAP"
	"\nParameter:\n----------\n"
	"nPortId :\n",
	/* 240: GSW_IG_CFG_PMAC_GET "*/
	"Read out the default PCE Bypass Q-MAP"
	"\nParameter:\n----------\n"
	"nPortId :\n"
	"nTxDmaChanId :\n",
	/* 241: GSW_DEBUG_PMAC_RMON_GET_ALL "*/
	"\nParameter:\n----------\n"
	"ePortType :\n"
	"Start :\n"
	"End \n",
	/* 242: GSW_PCE_RULE_ALLOC"*/
	"Allocate PCE Rule block to attach to CTP\n"
	"\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"nNumberOfEntries\n"
	"  Total number of PCE Rule entries to be requested. Value should\n"
	"  be times of 4.\n",
	/* 243: GSW_PCE_RULE_FREE"*/
	"Free PCE Rule block allocated with GSW_PCE_RULE_ALLOC\n"
	"\n"
	"Supported Parameters:\n"
	"----------------------\n"
	"nBlockId\n"
	"  Block ID allocated with GSW_PCE_RULE_ALLOC.\n",
	/* 244: GSW_DEBUG_PCERULETABLE_STATUS"*/
	"Debug internal PCE Rule Status table\n"
	"Supported Parameters:\n"
	"---------------------\n\n"
	"index\n"
	"  Entry to check or force set.\n"
	"blockid\n"
	"  Assign entry to this block id. Use with \"set=1\"."
	"set\n"
	"  Force set if value is 1.\n"
	"CheckAll (0 or 1)\n"
	"  List all used entries\n",

	/* 245: GSW_VXLAN_CFG_SET"*/
	"GSW_VXLAN_CFG_SET\n"
	"tSupported Parameters:\n"
	"---------------------\n\n"
	"nValue\n"
	"nIndex (0 or 1)\n",

	/* 246: GSW_VXLAN_CFG_GET"*/
	"GSW_VXLAN_CFG_GET\n"
	"Supported Parameters:\n"
	"---------------------\n\n"
	"nIndex (0 or 1)\n",

	/* 247: GSW_PCE_RULE_READ_ALL"*/
	"GSW_READ_PCE_TABLE\n"
	"Supported Parameters:\n"
	"---------------------\n\n"
	"nTableSize - PCE table size to read (any thing beyond suported size will give back error)\n",

	/* 248: GSW_QOS_METER_ALLOC*/
	"GSW_QOS_METER_ALLOC\n"
	"\tSupported Parameters:\n"
	"\t\t---------------------\n\n"
	"\t1.  No Parameters needed\n",
	/* 249: GSW_QOS_METER_FREE*/
	"It is used to release Meter Instance block allocated by\n"
	"ref GSW_QOS_METER_ALLOC_ALLOC.\n"
	"\nParameter:\n----------\n"
	"nMeterId :\n"
	"\tMeter Instance number (zero-based counting). \n"
	"\n",
	/* 250: GSW_PCE_RULE_ENABLE*/
	"It is used to Enable PCE Rule written by  GSW_PCE_RULE_WRITE\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.	pattern.nIndex:\n"
	"\t2.	nLogicalPortId:\n"
	"\t3.	nSubIfIdGroup:\n"
	"\t4.	nRegion:"
	"\n",
	/* 251: GSW_PCE_RULE_DISABLE*/
	"It is used to Disable PCE Rule written by  GSW_PCE_RULE_WRITE\n"
	"\tSupported Parameters:\n"
	"\t---------------------\n\n"
	"\t1.	pattern.nIndex:\n"
	"\t2.	nLogicalPortId:\n"
	"\t3.	nSubIfIdGroup:\n"
	"\t4.	nRegion:"
	"\n",

	NULL
};

//#endif /* SWITCHAPI_HELP_TEXT */
